---
title:  Palmer penguins and discrete predictors
description: |
  fitting a model with discrete predictors.
execute:
  freeze: auto
format:
  html:
    code-tools: true
---

Let's start by taking a look at the Palmer Penguin dataset. Let's look at the distribution of observations of bill size.

```{r}
#| fig-cap: Histogram of bill depth for all the penguins in the Palmer Penguin dataset.
library(tidyverse)
library(palmerpenguins)
penguins |> 
  ggplot(aes(x=bill_depth_mm)) + 
  geom_histogram(binwidth = .5)
```

There's quite a lot of variation in these measurements, with a suggestion of perhaps more than one peak in this distribution.

## A simple model

$$
\begin{align}
\text{Bill depth} &\sim \text{Normal}(\mu, \sigma)\\
\mu &\sim \text{Normal}(17.5, 2) \\
\sigma &\sim \text{Exponential}(1) \\
\end{align}
$$

let's express the same model in Stan:

```{r}
#| class-output: stan
library(cmdstanr)

normal_dist <- cmdstan_model("topics/discrete_predictor/normal_dist.stan")
normal_dist
```

The model section looks very much like the approach shown above. 
I want you to notice especially how the bottom chunk has three lines, each describing a probability distribution. 
These are for all the probability distribution of all the quantities in the model, both observed and unobserved. Above, we state which is which. 
Models are devices for putting together the probability of all the quantities we are looking for. Again, a Bayesian defines the world as umeasured or measured quantities -- and above we state which are observed (the data block) and which are unobserved (the parameters block).

We can fit this model to data and see the result: 

```{r}
# first we drop all NA values
penguins_nobillNA <- penguins |> 
  #drop NA values
  filter(!is.na(bill_depth_mm))

## then we assemble the data as a list.
## I'm using the base function with()
##  it lets me use the variable name directly 
## without writing penguins_nobillNA$bill_depth_mm

list_bill_dep <- with(penguins_nobillNA,
     list(N = length(bill_depth_mm),
          measurements = bill_depth_mm))
     
## sample 4 chains, suppress counting iterations
samp_bill_dep <- normal_dist$sample(data = list_bill_dep, 
                                    parallel_chains = 4,
                                    refresh = 0)

## summarize the samples for each parameter into a nice table
samp_bill_dep |> 
  posterior::summarise_draws() |> 
  flextable::flextable()
```


## Plotting parameters. 

We don't have one distribution for each of our unknown numbers: we have thousands. 
We need to get a sense of what these possible values mean scientifically. 
An excellent way to do this is by making as many pictures as possible. 
We will start with making plots of specific parameters. 

We can look at the distributions easily using the `bayesplot` package.

```{r}
#| layout-ncol: 2
draws <- samp_bill_dep$draws(variables = c("mu", "sigma"))

bayesplot::mcmc_hist(draws, pars = "mu")
bayesplot::mcmc_hist(draws, pars = "sigma")


```

Notice that the distributions do not have the same shape as the prior-- this is particularly true for $\sigma$. 
This shows an important point: the prior distribution does not determine what the posterior looks like. 
[should I sample from the prior and show them that?]{.aside}

```{r}
#| label: fig-dotsint
#| fig-cap: the package `ggdist` has many fun & useful ways to draw pictures of posterior distributions. Here is one called `stats_dotsinterval()`
#| column: margin
library(ggplot2)
library(ggdist)

draws |>  
  posterior::as_draws_df() |> 
  ggplot(aes(x = sigma)) + 
  stat_dotsinterval()
```

## Posterior predictions: the easy way to check your model

People care so much about model diagnostics. 
And with good reason: you need to know how much to trust a model before using it to make a scientific claim. 
One way to find out who's model is best would be to use them to make a prediction, and see how right you are. 
Nobody has the time for that. so instead the best choice is to see how well the data fit your sample. 

```{r}
# just get some draws
draws <- samp_bill_dep$draws(variables = c("mu", "sigma"))
draws_matrix <- posterior::as_draws_matrix(draws)

## set up a matrix. for every posterior sample, (that is, for a value of mu and a value of sigma) draw a whole fake dataset from a normal distribution with that mean and sd. 
nsamples <- 50
yrep <- matrix(0, ncol = list_bill_dep$N, nrow = nsamples)

# pick some random rows
set.seed(1234)
chosen_samples <- sample(1:nrow(draws_matrix), replace = FALSE, size = nsamples)
subset_draws <- draws_matrix[chosen_samples,]

for (r in 1:nsamples){
 yrep[r,] <- rnorm(n = list_bill_dep$N, 
                   mean = subset_draws[r, "mu"], 
                   sd = subset_draws[r, "sigma"])
}

bayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,
                            yrep = yrep)

```


### Posterior predictions in Stan

We can simulate our own data in R if we are comfortable translating between R and Stan. However, if you want, you can do the same process in Stan. Just combine the section we just looked at with the previous work on data simulation we started with: 

```{r}
#| class-output: stan

normal_dist_rng <- cmdstan_model(stan_file = "topics/discrete_predictor/normal_dist_rng.stan")

normal_dist_rng
```

Here we have a handy random number generator _inside_ Stan.

```{r}

samp_bill_dep_rng <- normal_dist_rng$sample(
  data = list_bill_dep,
  refresh = 0,
  parallel_chains = 4)

draws <- samp_bill_dep_rng$draws(variables = c("yrep"))
draws_matrix <- posterior::as_draws_matrix(draws)

bayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,
                            yrep = head(draws_matrix, 50))
```

The code is much shorter, because there is less to do in R. 
Both of these gives the same outcome: the posterior predictive distribution. 
This gives us a straightfoward way to test our model's performance: 

1. we use the model to generate fake observations. 
2. plot these on top of the real data
3. if the data is a really poor match, we know our model has a distorted view of the world.

## Different groups are different

let's add in differences among species

```{r}
penguins |> 
  ggplot(aes(x = bill_depth_mm, fill = species))+ 
  geom_histogram(binwidth = .5) + 
  scale_fill_brewer(palette = "Dark2")
```

Now we can see that the distribution is in fact three different shapes, all placed together. 

:::{.callout-warning}
Sometimes scientists will plot histograms of data at the beginning of a research project, and use the histogram to decide if their data are "normally distributed" or not. This is not helpful! Instead, decide on a model first, and ask yourself what kind of data you expect.
:::

## Stan code for species differences

```{r}
#| class-output: stan
normal_dist_rng_spp_forloop <- cmdstan_model(stan_file = "topics/discrete_predictor/normal_dist_rng_spp_forloop.stan")

normal_dist_rng_spp_forloop
```

There's a few differences to notice here:

* in the `data` block: We have a new input! A declaration of the array of integers at the top, saying if this is "species 1", "species 2", or "species 3"
* `mu` is a vector now. why?
* notice the for-loop. 

[Do we maybe add an illustration here of how vector indexing works?]{.aside}

We can write this model a different way as well: 

```{r}
#| class-output: stan
normal_dist_rng_spp <- cmdstan_model(stan_file = "topics/discrete_predictor/normal_dist_rng_spp.stan")

normal_dist_rng_spp
```

The only difference to the previous model is in the line with the for-loop, which is now replaced with a vectorized expression. This is faster to write and will run faster in Stan. However its not possible in every case. [add a link to the Stan forum]{.aside}

### Sampling the species model

We have to make a new data list, since we've added a new input: a vector of numbers 1, 2, or 3 that tells us if we are working with the first, second, or third species.

[which model to sample? here i'm doing the vectorized one just because]{.aside}

```{r}

list_bill_dep_spp <- with(penguins_nobillNA,
     list(
       N = length(bill_depth_mm),
       measurements = bill_depth_mm,
       spp_id = as.numeric(as.factor(species))
     )
)
     
samp_normal_dist_rng_spp <- normal_dist_rng_spp$sample(
  data = list_bill_dep_spp, 
  parallel_chains = 4,
  refresh = 0)

samp_normal_dist_rng_spp$draws(variables = c("mu", "sigma")) |> 
  posterior::summarise_draws() |> 
  flextable::flextable()

```

and we can repeat the posterior checking from before:

```{r}

spp_yrep_draws <- samp_normal_dist_rng_spp$draws(variables = c("yrep"))
spp_draws_matrix <- posterior::as_draws_matrix(spp_yrep_draws)

bayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,
                            yrep = head(spp_draws_matrix, 50))
```

The predicted distribution is now much more like the real data

We can also make figures for each individual species. 
Here we will move away from using `bayesplot` and try to visualize our posterior using the handy functions in the `tidybayes` package [add a link]{.aside}

```{r}
library(tidybayes)
spp_draws_df <- posterior::as_draws_df(spp_yrep_draws)

normal_dist_post_samp <- tidybayes::gather_draws(samp_normal_dist_rng_spp,
                        yrep[row_id], 
                        ndraws = 50)

normal_dist_post_samp |> 
  mutate(species = penguins_nobillNA$species[row_id]) |> 
  ggplot(aes(x = .value, colour = species)) + 
  geom_density(aes(group = .iteration), alpha = .1) + 
  facet_wrap(~species) + 
  geom_density(aes(x = bill_depth_mm),
               data = penguins_nobillNA,
               colour = "black") + 
  scale_colour_brewer(palette = "Dark2")

```


### Exercises


* repeat this experience for another variable in the dataset. Does the same code work on bill length? What about body size? 
* use bayesplot to examine the fit of body size to these data. 
* generate some random groups of your own and 
* the function `tidybayes::compose_data` is a convenient way to set up your data for passing it into R. Try out this function. What does it produce for our dataset? How do you need to modify our Stan program so that it works for the output of `tidybayes::compose_data`?
