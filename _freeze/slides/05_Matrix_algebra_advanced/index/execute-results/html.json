{
  "hash": "74c146b06718695b54f5dddf34e429e6",
  "result": {
    "markdown": "---\ntitle: \"Matrix algebra\"\ntitle-slide-attributes: \n  data-background-image: ../img/bg.jpg\n  data-background-size: full\nauthor: \"Andrew MacDonald and Guillaume Blanchet and Vincent Tolon\"\ndate: \"2023-02-10\"\nexecute:\n  echo: true\nformat: \n  revealjs:\n    theme: [default]\n    logo: ../img/UdeS_logo_h_rgbHR.png\n    transition: slide\n    background-transition: fade\n---\n\n\n## A general way to write matrices\n$$\n\\mathbf{A} = \\begin{bmatrix}\n\t\t\t\tA_{11} & A_{12} & \\dots & A_{1j} & \\dots & A_{1n}\\\\\n\t\t\t\tA_{21} & A_{22} & \\dots & A_{2j} & \\dots & A_{2n}\\\\\n\t\t\t\t\\vdots & \\vdots & \\ddots & \\vdots & & \\vdots\\\\\n\t\t\t  A_{i1} & A_{i2} & \\dots & A_{ij} & \\dots & A_{in}\\\\\n\t\t    \\vdots & \\vdots & & \\vdots & \\ddots & \\vdots\\\\\n\t\t    A_{m1} & A_{m2} & \\dots & A_{mj} & \\dots & A_{mn}\\\\\n\t\t\\end{bmatrix}\n$$\n$$A = \\left[a_{ij}\\right]=\\left[a_{ij}\\right]_{m\\times n}$$\n\n# Basic matrix operations\n\n## The transpose of a matrix\n\n::::: { style=\"font-size: 0.65em\"}\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n$$A = \\begin{bmatrix}\n          5 & -6 & 4 & -4\\\\\n        \\end{bmatrix}\n$$\n\n$$B = \\begin{bmatrix}\n          -8\\\\\n          9\\\\\n          -2\\\\\n        \\end{bmatrix}\n$$\n\n$$C = \\begin{bmatrix}\n          -4 & 1\\\\\n          2 & -5\\\\\n        \\end{bmatrix}\n$$\n:::\n\n::: {.column width=\"50%\"}\n\n$$A^t=\\begin{bmatrix}\n          5\\\\\n          -6\\\\\n          4\\\\\n          -4\\\\\n        \\end{bmatrix}\n$$\n    \n \n$$B^t =\\begin{bmatrix}\n          -8 & 9 & -2\\\\\n        \\end{bmatrix}\n$$\n    \n\n$$C^t =\\begin{bmatrix}\n          -4 & 2\\\\\n          1 & -5\\\\\n        \\end{bmatrix}\n$$\n:::\n::::\n\nIn R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3, 1, 5, -2), nrow = 2, ncol = 2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    3    5\n[2,]    1   -2\n```\n:::\n\n```{.r .cell-code}\nt(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    3    1\n[2,]    5   -2\n```\n:::\n:::\n\n:::::\n## Addition and Substraction\n\n$$\\mathbf{C} = \\mathbf{A}\\pm \\mathbf{B}$$\n$$C_{ij} = A_{ij} \\pm B_{ij}$$\n\n::: {style=\"color: blue;\"}\n$$\\begin{bmatrix}\n\t\t\t\t3 & 5\\\\\n\t\t\t\t1 & -2\\\\\n\t\t\t\\end{bmatrix} + \n\t\t\t\\begin{bmatrix}\n\t\t\t\t2 & 1\\\\\n\t\t\t\t4 & -2\\\\\n\t\t\t\\end{bmatrix} = \n\t\t\t\\begin{bmatrix}\n\t\t\t\t3+2 & 5+1\\\\\n\t\t\t\t1+4 & -2-2\\\\\n\t\t\t\\end{bmatrix} = \n\t\t\t\\begin{bmatrix}\n\t\t\t\t5 & 6\\\\\n\t\t\t\t5 & -4\\\\\n\t\t\t\\end{bmatrix}$$\n:::\n\nIn R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3, 1, 5, -2), nrow = 2, ncol = 2)\nB <- matrix(c(2, 4, 1, -2), nrow = 2, ncol = 2)\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    5    6\n[2,]    5   -4\n```\n:::\n:::\n\n\n## Multiplying a matrix by a scalar\n\t\n$$\\mathbf{B} = c\\mathbf{A}$$\n$$B_{ij} = cA_{ij}$$\n\t\n::: {style=\"color: blue;\"}\n$$\n\t\t\t0.3 \\begin{bmatrix}\n\t\t\t\t3 & 5\\\\\n\t\t\t\t1 & -2\\\\\n\t\t\t\\end{bmatrix} =  \n\t\t\t\\begin{bmatrix}\n\t\t\t\t0.9 & 1.5\\\\\n\t\t\t\t0.3 & -0.6\\\\\n\t\t\t\\end{bmatrix}\n$$\n:::\t\t\n\nIn R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3, 1, 5, -2), nrow = 2, ncol = 2)\nc <- 0.3\nc*A \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]  0.9  1.5\n[2,]  0.3 -0.6\n```\n:::\n:::\n\n\n## Matrix multiplications (not divisions!)\n\t\n$$\\mathbf{C} = \\mathbf{A} \\cdot \\mathbf{B}$$\n\n$$C_{ik} = \\sum^{n}_{j=1}A_{ij}B_{jk}$$\n\n**Rules**\n\t\nAssociative: $\\mathbf{A}(\\mathbf{B}\\mathbf{C}) = (\\mathbf{A}\\mathbf{B})\\mathbf{C}$ \n\t\nDistributive: $\\mathbf{A}(\\mathbf{B} + \\mathbf{C}) = \\mathbf{A}\\mathbf{B}+\\mathbf{A}\\mathbf{C}$\n\t\nNot commutative: $\\mathbf{A}\\mathbf{B} \\neq \\mathbf{B}\\mathbf{A}$\n\n\n## Inner product\n$$(\\mathbf{Ax})_i=\\sum_{j=1}^{n}A_{ij}x_j$$\n\n:::{style=\"color: blue;\"}\n$$\n  \\begin{bmatrix}\n    3 & 5\\\\\n    1 & -2\\\\\n  \\end{bmatrix}\n  \\begin{bmatrix}\n    2\\\\ 5\\\\\n  \\end{bmatrix} = \n  \\begin{bmatrix}\n    (3, 5) \\cdot (2, 5)\\\\\n    (1, -2) \\cdot (2, 5) \\\\\n  \\end{bmatrix} = \n  \\begin{bmatrix}\n    3 \\times 2 + 5 \\times 5\\\\\n    1 \\times 2 -2 \\times 5\\\\\n  \\end{bmatrix} = \n  \\begin{bmatrix}\n    31\\\\\n    -8\\\\\n  \\end{bmatrix}\n$$\n:::\n\nIn R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3, 1, 5, -2), nrow = 2, ncol = 2)\nx <- matrix(c(2,5), nrow = 2, ncol = 1)\nA %*% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]   31\n[2,]   -8\n```\n:::\n:::\n\n\n# Some important matrices\n\n\n## Identity matrix\n\nThe identity matrix is a square matrix where all values of its diagonal are 0 except  the diagonal values which are all 1s.\n\n:::: { style=\"font-size: 0.8em\"}\n::: {style=\"color: blue;\"}\n$$\n\\mathbf{I}=\\begin{bmatrix}\n\t\t\t\t1 & 0 & 0\\\\\n\t\t\t\t0 & 1 & 0\\\\\n\t\t\t\t0 & 0 & 1\\\\\n\t\t\\end{bmatrix}\n$$\n:::\n\nThe identity matrix is important because \n\n$$\\mathbf{A} \\cdot \\mathbf{I}_n = \\mathbf{A}$$\nor \n\n$$\\mathbf{I}_m \\cdot \\mathbf{A} = \\mathbf{A}$$\n::::\n\n\n## Diagonal matrix\n\nThe diagonal matrix is a square matrix where all values of its diagonal are 0 except the ones on the diagonal.\n\n:::: {style=\"font-size: 0.8em\"}\n$$D=\n      \\begin{bmatrix}\n        d_1 & 0 & \\dots & 0\\\\\n        0 & d_2 & \\dots & 0\\\\\n        \\vdots & \\vdots & \\ddots & \\vdots\\\\\n        0 & 0 & \\dots & d_n\\\\\n\\end{bmatrix}$$\n\nAn example\n\n::: {style=\"color: blue;\"}\n$$\n\\begin{bmatrix}\n\t\t\t\t-1 & 0 & 0\\\\\n\t\t\t\t0 & 0 & 0\\\\\n\t\t\t\t0 & 0 & 6\\\\\n\t\t\\end{bmatrix}\n$$\n:::\n::::\n\n## Triangular matrix\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n#### Lower triangular matrix\n$$\\begin{bmatrix}\n        -10 & 0 & 0 & 0\\\\\n        3 & 0 & 0 & 0\\\\\n        0 & 4 & 3 & 0\\\\\n        9 & -5 & 4 & 3\\\\\n\\end{bmatrix}$$\n:::\n::: {.column width=\"50%\"}\n#### Upper triangular matrix\n$$\\begin{bmatrix}\n        -10 & 0 & -5 & 0\\\\\n        0 & 0 & 5 & 6\\\\\n        0 & 0 & 3 & 3\\\\\n        0 & 0 & 0 & 3\\\\\n      \\end{bmatrix}$$\n:::\n::::\n\n## Symmetric matrix\n\nThe values on the  above and below the diagonal are match so that $A = A^t$\n\n::: {style=\"color: blue;\"}\n$$\n\\begin{bmatrix}\n\t\t\t\t3 & 4 & -10\\\\\n\t\t\t\t4 & 5 & 7\\\\\n\t\t\t\t-10 & 7 & -6\\\\\n\t\t\\end{bmatrix}\n$$\n:::\n\n## Matrix inversion\n\n::: { style=\"font-size: 0.8em\"}\nIn matrix algebra, we cannot divide a matrix by another matrix, but we can multiple it by its inverse, which gets us to the same place. Classically, the inverse of matrix $\\mathbf{A}$ is defined as $\\mathbf{A}^{-1}$\n\nAs such,\n$$\\mathbf{A}\\cdot \\mathbf{A}^{-1} = \\mathbf{I}$$ \nIn R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(3, 1, 5, -2), nrow = 2, ncol = 2)\n(Ainv <- solve(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,] 0.18181818  0.4545455\n[2,] 0.09090909 -0.2727273\n```\n:::\n\n```{.r .cell-code}\nA %*% Ainv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              [,1] [,2]\n[1,]  1.000000e+00    0\n[2,] -2.775558e-17    1\n```\n:::\n:::\n\n:::\n\n## Matrix inversion\n### Inverting a diagonal matrix\n\n$$D^{-1}=\n      \\begin{bmatrix}\n        1/d_1 & 0 & \\dots & 0\\\\\n        0 &  1/d_2 & \\dots & 0\\\\\n        \\vdots & \\vdots & \\ddots & \\vdots\\\\\n        0 & 0 & \\dots &  1/d_n\\\\\n\\end{bmatrix}$$\n\n\n\n## Cholesky decomposition\n\n::: { style=\"font-size: 0.8em\"}\nThe Cholesky decomposition allows to decompose a matrix in a triangular, which, when multiplied by its transposed will allow us to recover the initial matrix. \n\nIn coloquial terms, the Cholesky decomposition is the equivalent of a square root for matrice\n\nIn math terms the Cholesky decomposition is defined as \n$$\\mathbf{A} = \\mathbf{L}\\mathbf{L}^t$$\nExample\n\n$$\n\t\t\\begin{bmatrix}\n\t\t\t1 & 1 & 1\\\\\n\t\t\t1 & 5 & 5\\\\\n\t\t\t1 & 5 & 14\\\\\n\t\t\\end{bmatrix}=\n\t\t\\begin{bmatrix}\n\t\t\t1 & 0 & 0\\\\\n\t\t\t1 & 2 & 0\\\\\n\t\t\t1 & 2 & 3 \\\\\n\t\t\\end{bmatrix}\n\t\t\\begin{bmatrix}\n\t\t\t1 & 1 & 1\\\\\n\t\t\t0 & 2 & 2\\\\\n\t\t\t0 & 0 & 3 \\\\\n\t\t\\end{bmatrix}\n$$\n:::\n\n\n## Cholesky decomposition\n\n### Why is it useful ?\n\nThere are actually two main reasons :\n\n1. Working with triangular matrices is computationally more efficient\n2. It can be used to rescale matrices and make MCMC algorithms converge more easily\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}