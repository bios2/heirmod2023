{
  "hash": "f81b7599d6cd29554687ac1bee3df6cb",
  "result": {
    "markdown": "---\ntitle: \"Summarizing many univariate models\"\ndescription: |\n  A secret weapon for when you're building hierarchical models.\nexecute:\n  freeze: auto\nformat:\n  html:\n    code-tools: true\n---\n\n\nWe've already looked at univariate models.\nWhen we fit the same model to multiple different groups, we don't expect the same values for all the coefficients.\nEach thing we are studying will respond to the same variable in different ways. \n\nHierarchial models represent a way to _model_ this variation, in ways that range from simple to complex. \n\nBefore we dive in with hierarchical structure, let's build a bridge between these two approaches. \n\nThis is useful to help us understand what a hierarchical model does.\n\nHowever it is also useful from a strict model-building perspective -- so useful that Andrew Gelman calls it a \"Secret Weapon\" tk link\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\n\n# combine data and environment\nlibrary(tidyverse)\nmite_data_long <- bind_cols(mite.env, mite) |> \n  pivot_longer(Brachy:Trimalc2, names_to = \"spp\", values_to = \"abd\")\n```\n:::\n\n\n\nTo keep things simple and univariate, let's consider only water:\n\nFirst, a quick word about centering and scaling a predictor variable:\n\n1. I center the predictor by subtracting the mean. This changes the _intercept_ of my linear predictor. it becomes the mean log-odds of occurrance when the water content is average\n2. I divide water content by 100. The dataset has units of **grams per Litre** of water (see `?vegan::mite.env` for more details). This is fine, but I don't think mites are able to sense differences as precise as a millimeter of water either way. by dividing by 10 I transform this into centilitres, which is more informative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_long_transformed <- mite_data_long |> \n  mutate(presabs = as.numeric(abd>0),\n         # center predictors\n         water = (WatrCont - mean(WatrCont)) / 100\n         )\n\nmite_data_long_transformed |> \n  ggplot(aes(x = water, y = presabs)) + \n  geom_point() + \n  stat_smooth(method = \"glm\", method.args = list(family = \"binomial\")) + \n  facet_wrap(~spp)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](secret_weapon_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nsome things to notice about this figure: \n\n* the x-axis scale has been transformed from \"grams per litre\" to \"centilitres away from average\n* there is a ton of variation in how different species respond to water!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glms <- mite_data_long_transformed |> \n  nest_by(spp) |> \n  mutate(logistic_regressions = list(\n    glm(presabs ~ water,\n        family = \"binomial\",\n        data = data))) |> \n  mutate(coefs = list(broom::tidy(logistic_regressions)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glm_coefs <- mite_many_glms |> \n  select(-data, -logistic_regressions) |> \n  unnest(coefs)\n\nmite_many_glm_coefs |> \n  ggplot(aes(x = estimate, y = spp,\n             xmin = estimate - std.error,\n             xmax = estimate + std.error)) + \n  geom_pointrange() + \n  facet_wrap(~term, scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](secret_weapon_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nAs you can see, some of these estimates are high, others low. \nWe could also plot these as histograms to see this distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glm_coefs |> \n  ggplot(aes(x = estimate)) + \n  geom_histogram(binwidth = .5) + \n  facet_wrap(~term, scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](secret_weapon_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nOnce again, the two parameters of this model represent:\n\n* *Intercept* The probability (in log-odds) of a species being present at the average water concentration.\nsome species are common, others are rare.\n* *water* this is the change in probability (in log-odds) as water increases by one centilitre per litre of substrate.\n\n\n## Say it in Stan\n\nThe above tidyverse approach is very appealing and intuitive, but we can also do the same procedure in Stan.\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Modelling variation in slopes\n\nClearly there is variation among species in the values of these parameters.\nLike all variation, we can develop a scientific model to describe it.\nThe simplest model we'll consider is a simple univariate distribution.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(cmdstanr))\n\nlogistic_bern_glm <- cmdstan_model(\n  stan_file = here::here(\"topics/secret_weapon_univariate.stan\"), \n  pedantic = TRUE)\n\nmite_bin <- mite\nmite_bin[mite_bin>0] <- 1\n\nlogistic_bern_glm$sample(data = list(\n  Nsites = nrow(mite_bin),\n  K = 2,\n  S = ncol(mite_bin),\n  x = cbind(1, with(mite.env, (WatrCont - mean(WatrCont))/100)),\n  y = as.matrix(mite_bin)\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\nRunning MCMC with 4 sequential chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 9.2 seconds.\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 9.3 seconds.\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 10.0 seconds.\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 12.8 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 10.3 seconds.\nTotal execution time: 42.0 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\n variable     mean   median   sd  mad       q5      q95 rhat ess_bulk ess_tail\n   lp__   -1171.18 -1170.78 8.32 8.07 -1185.34 -1157.97 1.00      643     1511\n   z[1,1]     1.67     1.65 0.36 0.36     1.11     2.29 1.00     1214     2032\n   z[2,1]     0.04     0.04 0.39 0.37    -0.62     0.67 1.00     2184     2490\n   z[1,2]    -0.41    -0.40 0.26 0.25    -0.86     0.00 1.00      839     1684\n   z[2,2]    -0.92    -0.90 0.43 0.41    -1.68    -0.26 1.00     2123     2361\n   z[1,3]     2.06     2.04 0.42 0.41     1.41     2.80 1.00     1256     2335\n   z[2,3]    -0.10    -0.09 0.42 0.40    -0.81     0.58 1.00     2376     2473\n   z[1,4]    -0.62    -0.61 0.28 0.28    -1.09    -0.17 1.00      706     1606\n   z[2,4]    -1.04    -1.02 0.45 0.44    -1.80    -0.36 1.00     1918     2508\n   z[1,5]    -1.07    -1.06 0.32 0.32    -1.61    -0.57 1.01      770     1442\n\n # showing 10 of 145 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n\nlet's take a look at these values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"mite.xy\", package = \"vegan\")\nmite.xy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x   y\n1  0.20 0.1\n2  1.00 0.1\n3  1.20 0.3\n4  1.40 0.5\n5  2.40 0.7\n6  1.80 0.9\n7  0.05 1.1\n8  2.00 1.3\n9  2.00 1.5\n10 1.20 1.7\n11 2.40 1.9\n12 0.20 2.1\n13 0.40 2.1\n14 2.00 2.3\n15 2.20 2.3\n16 0.05 2.7\n17 0.20 2.7\n18 2.20 2.7\n19 2.40 2.7\n20 1.20 2.9\n21 0.05 3.1\n22 1.40 3.1\n23 2.40 3.1\n24 0.20 3.5\n25 1.20 3.7\n26 0.80 3.9\n27 1.60 3.9\n28 0.20 4.1\n29 0.80 4.1\n30 1.80 4.5\n31 0.20 4.7\n32 1.40 4.7\n33 0.60 5.3\n34 1.00 5.3\n35 2.40 5.3\n36 1.40 5.5\n37 1.80 5.5\n38 0.40 5.9\n39 1.00 5.9\n40 1.80 5.9\n41 2.00 5.9\n42 0.05 6.1\n43 0.20 6.1\n44 0.40 6.1\n45 1.20 6.1\n46 1.60 6.1\n47 1.60 6.3\n48 0.40 6.5\n49 1.80 6.7\n50 0.60 6.9\n51 2.00 7.1\n52 0.05 7.3\n53 0.40 7.3\n54 1.40 7.5\n55 2.20 7.5\n56 0.20 7.9\n57 1.60 7.9\n58 2.40 7.9\n59 0.05 8.1\n60 1.20 8.1\n61 1.40 8.1\n62 2.00 8.1\n63 1.60 8.5\n64 1.60 8.7\n65 1.00 8.9\n66 1.60 8.9\n67 2.40 9.1\n68 2.20 9.3\n69 1.80 9.5\n70 0.40 9.7\n```\n:::\n\n```{.r .cell-code}\nnrow(mite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70\n```\n:::\n:::\n",
    "supporting": [
      "secret_weapon_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}