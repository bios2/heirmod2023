{
  "hash": "06f2c41beb72efe58005e8f67574214f",
  "result": {
    "markdown": "---\ntitle: \"Summarizing many univariate models\"\ndescription: |\n  A secret weapon for when you're building hierarchical models.\nexecute:\n  freeze: true\nformat:\n  html:\n    code-tools: true\n---\n\n\nWe've already looked at univariate models. When we fit the same model to multiple different groups, we don't expect the same values for all the coefficients. Each thing we are studying will respond to the same variable in different ways.\n\nHierarchial models represent a way to *model* this variation, in ways that range from simple to complex.\n\nBefore we dive in with hierarchical structure, let's build a bridge between these two approaches.\n\nThis is useful to help us understand what a hierarchical model does.\n\nHowever it is also useful from a strict model-building perspective -- so useful that [Andrew Gelman calls it a \"Secret Weapon\"](https://statmodeling.stat.columbia.edu/2005/03/07/the_secret_weap/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\nlibrary(tidyverse)\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is cmdstanr version 0.5.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan path: /Users/amacdonald/.cmdstan/cmdstan-2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan version: 2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable CMDSTANR_NO_VER_CHECK=TRUE.\n```\n:::\n\n```{.r .cell-code}\n# combine data and environment\nmite_data_long <- bind_cols(mite.env, mite) |> \n  pivot_longer(Brachy:Trimalc2, names_to = \"spp\", values_to = \"abd\")\n```\n:::\n\n\nTo keep things simple and univariate, let's consider only water:\n\nFirst, a quick word about centering and scaling a predictor variable:\n\n1.  I center the predictor by subtracting the mean. This changes the *intercept* of my linear predictor. it becomes the mean log-odds of occurrance when the water content is average\n2.  I divide water content by 100. The dataset has units of **grams per Litre** of water (see `?vegan::mite.env` for more details). This is fine, but I don't think mites are able to sense differences as precise as a millimeter of water either way. by dividing by 10 I transform this into centilitres, which is more informative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_long_transformed <- mite_data_long |> \n  mutate(presabs = as.numeric(abd>0),\n         # center predictors\n         water = (WatrCont - mean(WatrCont)) / 100\n         )\n\nmite_data_long_transformed |> \n  ggplot(aes(x = water, y = presabs)) + \n  geom_point() + \n  stat_smooth(method = \"glm\", method.args = list(family = \"binomial\")) + \n  facet_wrap(~spp)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nsome things to notice about this figure:\n\n-   the x-axis scale has been transformed from \"grams per litre\" to \"centilitres away from average\n-   there is a ton of variation in how different species respond to water!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glms <- mite_data_long_transformed |> \n  nest_by(spp) |> \n  mutate(logistic_regressions = list(\n    glm(presabs ~ water,\n        family = \"binomial\",\n        data = data))) |> \n  mutate(coefs = list(broom::tidy(logistic_regressions)))\n```\n:::\n\n\n:::{.callout-note}\n## Split-Apply-Combine\n\nTo explore this kind of thinking, we are going to use an approach sometimes called [\"split-apply-combine\"](https://vita.had.co.nz/papers/plyr.pdf)\n\nThere are many possible ways to do this in practice. We are using a technique here from the tidyverse, which you can [read more about](https://dplyr.tidyverse.org/articles/rowwise.html).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glm_coefs <- mite_many_glms |> \n  select(-data, -logistic_regressions) |> \n  unnest(coefs)\n\nmite_many_glm_coefs |> \n  ggplot(aes(x = estimate, y = spp,\n             xmin = estimate - std.error,\n             xmax = estimate + std.error)) + \n  geom_pointrange() + \n  facet_wrap(~term, scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nAs you can see, some of these estimates are high, others low. We could also plot these as histograms to see this distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_many_glm_coefs |> \n  ggplot(aes(x = estimate)) + \n  geom_histogram(binwidth = .5) + \n  facet_wrap(~term, scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nOnce again, the two parameters of this model represent:\n\n-   *Intercept* The probability (in log-odds) of a species being present at the average water concentration. some species are common, others are rare.\n-   *water* this is the change in probability (in log-odds) as water increases by one centilitre per litre of substrate.\n\n## Say it in Stan\n\nThe above tidyverse approach is very appealing and intuitive, but we can also do the same procedure in Stan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_species_unpooled <- cmdstan_model(\n  stan_file = \"topics/correlated_effects/all_species_unpooled.stan\", \n  pedantic = TRUE)\n\nall_species_unpooled\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  // number of rows in dataset\n  int<lower=0> Nsites;\n  // number of species\n  int<lower=0> S;\n  // one environmental variable to use in prediction\n  vector[Nsites] x;\n  // response site (rows) by species (columns) 2D array\n  array[Nsites,S] int <lower=0,upper=1> y;\n}\nparameters {\n  // parameters are now VECTORS\n  vector[S] intercept;\n  vector[S] slope;\n}\nmodel {\n  for (s in 1:S){\n    y[,s] ~ bernoulli_logit(intercept[s] + slope[s] * x);\n  }\n  // priors don't change because Stan is vectorized:\n  // every element of the vector gets the same prior\n  intercept ~ normal(0, .5);\n  slope ~ normal(0, .5);\n}\n```\n:::\n:::\n\n\nLet's fit this model by passing in the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_bin <- mite\nmite_bin[mite_bin>0] <- 1\n\nmite_pa_list <- list(\n      Nsites = nrow(mite_bin),\n      S = ncol(mite_bin),\n      x = with(mite.env, (WatrCont - mean(WatrCont))/100),\n      y = as.matrix(mite_bin)\n    )\n\nall_species_unpooled_posterior <- \n  all_species_unpooled$sample(\n    data = mite_pa_list, \n    refresh = 1000, parallel_chains = 4\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 8.4 seconds.\nChain 2 finished in 8.4 seconds.\nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 8.8 seconds.\nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 9.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 8.8 seconds.\nTotal execution time: 9.5 seconds.\n```\n:::\n:::\n\n\nnow let's try to plot this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# start by looking at the names of variables\n# get_variables(all_species_unpooled_posterior)\n\npost_pred <- tidybayes::spread_rvars(all_species_unpooled_posterior, \n             intercept[spp_id], slope[spp_id]) |> \n  expand_grid(water = seq(from = -4, to = 4, length.out = 10)) |> \n  mutate(prob = posterior::rfun(plogis)(intercept + slope*water),\n         spp = colnames(mite_bin)[spp_id]) |> \n  ggplot(aes(x = water, dist = prob)) + \n  tidybayes::stat_lineribbon() + \n  facet_wrap(~spp) + \n  scale_fill_brewer(palette = \"Greens\")\n\npost_pred\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nWe can imitate the original figure by adding the observed data in orange:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npost_pred + \n  geom_point(aes(x = water, y = presabs), \n             inherit.aes = FALSE, \n             data = mite_data_long_transformed,\n             pch = 21, \n             fill = \"orange\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nPlot and compare to frequentist point estimates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_rvars <- tidybayes::gather_rvars(\n  all_species_unpooled_posterior, \n             intercept[spp_id], slope[spp_id]) \n\n\nmite_many_glm_coefs |> \n  select(spp, term, estimate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 Ã— 3\n# Groups:   spp [35]\n   spp      term        estimate\n   <chr>    <chr>          <dbl>\n 1 Brachy   (Intercept)   2.43  \n 2 Brachy   water        -0.547 \n 3 Ceratoz1 (Intercept)   0.466 \n 4 Ceratoz1 water         0.0273\n 5 Ceratoz3 (Intercept)  -0.237 \n 6 Ceratoz3 water         0.280 \n 7 Eupelops (Intercept)  -0.464 \n 8 Eupelops water        -0.535 \n 9 FSET     (Intercept)  -0.644 \n10 FSET     water        -1.82  \n# â„¹ 60 more rows\n```\n:::\n:::\n\n\n## Saying it another way: with matrix algebra\n\nFirst let's look at how to scale a univariate distribution:\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nz <- rnorm(300, mean = 0, sd = 1)\nhist(z)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsd(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.036493\n```\n:::\n\n```{.r .cell-code}\nhist(z*2.7)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsd(z*2.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.798532\n```\n:::\n:::\n\n\nyou can also scale two things at once with a diagonal matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_sds <- diag(c(.4, 7))\n\nzz <- matrix(rnorm(200), ncol = 2)\n\nrescaled_zz <- zz %*% two_sds\n\nplot(rescaled_zz)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\napply(rescaled_zz, 2, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3824816 6.5854028\n```\n:::\n:::\n\n\nWe can apply this approach in Stan to create the SAME model as above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_species_unpooled_diag <- cmdstan_model(\n  stan_file = \"topics/correlated_effects/all_species_unpooled_diag.stan\", \n  pedantic = TRUE)\n\nall_species_unpooled_diag\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> Nsites;         // num of sites in the dataset\n  // int<lower=1> 2;              // num of site predictors\n  int<lower=1> S;              // num of species\n  matrix[Nsites, 2] x;         // site-level predictors\n  array[Nsites, S] int<lower=0, upper=1> y;  // species presence or absence\n}\ntransformed data {\n vector<lower=0>[2] sd_params = [0.5, 0.5]'; \n}\nparameters {\n  // species departures from the average\n  matrix[2, S] z;               \n  // AVERAGE of slopes and intercepts\n  vector[2] gamma;\n}\ntransformed parameters {\n  matrix[2, S] beta = rep_matrix(gamma, S) + diag_pre_multiply(sd_params, z);\n}\nmodel {\n  matrix[Nsites, S] mu;\n  // calculate the model average\n  mu = x * beta;\n  // Likelihood\n  for (s in 1:S) {\n    y[,s] ~ bernoulli_logit(mu[,s]);\n  }\n  // priors\n  to_vector(z) ~ std_normal();\n  gamma ~ normal(0, 2);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nall_species_unpooled_diag_sample <- all_species_unpooled_diag$sample(\n  data = mite_pa_list, \n  refresh = 1000, parallel_chains = 4\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: mismatch in number dimensions declared and found in context; processing stage=data initialization; variable name=x; dims declared=(70,2); dims found=(70) (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpIYAnRk/model-17206293b69f8.stan', line 5, column 2 to column 22)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Exception: mismatch in number dimensions declared and found in context; processing stage=data initialization; variable name=x; dims declared=(70,2); dims found=(70) (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpIYAnRk/model-17206293b69f8.stan', line 5, column 2 to column 22)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 Exception: mismatch in number dimensions declared and found in context; processing stage=data initialization; variable name=x; dims declared=(70,2); dims found=(70) (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpIYAnRk/model-17206293b69f8.stan', line 5, column 2 to column 22)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: mismatch in number dimensions declared and found in context; processing stage=data initialization; variable name=x; dims declared=(70,2); dims found=(70) (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpIYAnRk/model-17206293b69f8.stan', line 5, column 2 to column 22)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Chain 1 finished unexpectedly!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Chain 2 finished unexpectedly!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Chain 3 finished unexpectedly!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Chain 4 finished unexpectedly!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: All chains finished unexpectedly! Use the $output(chain_id) method for more information.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Use read_cmdstan_csv() to read the results of the failed chains.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No chains finished successfully. Unable to retrieve the fit.\n```\n:::\n:::\n\n\n\n## Making it hierarchical\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_species_partpooled_diag <- cmdstan_model(\n  stan_file = \"topics/correlated_effects/all_species_partpooled_diag.stan\", \n  pedantic = TRUE)\n\nall_species_partpooled_diag\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> Nsites;         // num of sites in the dataset\n  int<lower=1> S;              // num of species\n  matrix[Nsites, 2] x;         // site-level predictors\n  array[Nsites, S] int<lower=0, upper=1> y;  // species presence or absence\n}\nparameters {\n  matrix[2, S] z;               // species departures from the average\n  vector[2] gamma;              // AVERAGE of slopes and intercepts\n  vector<lower=0>[2] sd_params;          // standard deviations of species departures\n}\ntransformed parameters {\n  matrix[2, S] beta = rep_matrix(gamma, S) + diag_pre_multiply(sd_params, z);\n}\nmodel {\n  matrix[Nsites, S] mu;\n  // calculate the model average\n  mu = x * beta;\n  // Likelihood\n  for (s in 1:S) {\n    y[,s] ~ bernoulli_logit(mu[,s]);\n  }\n  // priors\n  to_vector(z) ~ std_normal();\n  sd_params ~ exponential(2);\n  gamma ~ normal(0, 2);\n}\n```\n:::\n:::\n\n\n## Modelling COvariation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_species_partpooled_diag_corr <- cmdstan_model(\n  stan_file = \"topics/correlated_effects/all_species_partpooled_diag_corr.stan\", \n  pedantic = TRUE)\n\nall_species_partpooled_diag_corr\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> Nsites;         // num of sites in the dataset\n  int<lower=1> S;              // num of species\n  matrix[Nsites, 2] x;         // site-level predictors\n  array[Nsites, S] int<lower=0, upper=1> y;  // species presence or absence\n}\nparameters {\n  // species departures from the average\n  matrix[2, S] z;               \n  // AVERAGE of slopes and intercepts\n  vector[2] gamma;              \n  // standard deviations of species departures\n  vector<lower=0>[2] sd_params; \n  // add the correlations between slope and intercept\n  cholesky_factor_corr[2] slope_inter_corr;\n}\ntransformed parameters {\n  matrix[2, S] beta = rep_matrix(gamma, S) + \n    diag_pre_multiply(sd_params, slope_inter_corr) * z;\n}\nmodel {\n  matrix[Nsites, S] mu;\n  // calculate the model average\n  mu = x * beta;\n  // Likelihood\n  for (s in 1:S) {\n    y[,s] ~ bernoulli_logit(mu[,s]);\n  }\n  // priors\n  to_vector(z) ~ std_normal();\n  sd_params ~ exponential(2);\n  gamma ~ normal(0, 2);\n  slope_inter_corr ~ lkj_corr_cholesky(2);\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_list <- list(\n  Nsites = nrow(mite_bin),\n  K = 2,\n  S = ncol(mite_bin),\n  x = cbind(1, with(mite.env, (WatrCont - mean(WatrCont))/100)),\n  y = as.matrix(mite_bin))\n\nall_species_partpooled_diag_posterior <- all_species_partpooled_diag$sample(\n  data = mite_data_list,\n  refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 4 finished in 11.7 seconds.\nChain 1 finished in 12.7 seconds.\nChain 2 finished in 13.6 seconds.\nChain 3 finished in 13.6 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 12.9 seconds.\nTotal execution time: 13.8 seconds.\n```\n:::\n:::\n\n\n\nplot these, reproducing the figure from earlier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the unpooled numbers\nunpooled_slopes <- all_species_unpooled_posterior |> \n  tidybayes::gather_rvars(slope[spp])\n\n# tidybayes::get_variables(all_species_partpooled_diag_posterior)\n\npartpooled_slopes <- all_species_partpooled_diag_posterior |> \n  tidybayes::gather_rvars(beta[param, spp]) |> \n  filter(param == 2)\n\nleft_join(unpooled_slopes, partpooled_slopes, by = \"spp\") |> \n  ggplot(aes(x = mean(.value.x), y = mean(.value.y))) + \n  geom_point() + \n  geom_abline(intercept = 0, slope = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n## Correlating numbers with a cholesky decomposition of a correlation matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neg <- rethinking::rlkjcorr(1, 2, 1)\ncc <- chol(eg)\n\nzz <- matrix(data = rnorm(2000), ncol = 2)\nplot(zz)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncor(zz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]        [,2]\n[1,] 1.000000000 0.005528595\n[2,] 0.005528595 1.000000000\n```\n:::\n\n```{.r .cell-code}\nrr <- t(cc) %*% t(zz)\nplot(t(rr))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n\n```{.r .cell-code}\ncor(t(rr))[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.8276924\n```\n:::\n:::\n\n\nThe LKJ prior distribution is a prior over correlation matrices\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rethinking::rlkjcorr(1, 5, .3)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}