{
  "hash": "8c224deb4124842adbbdfa5d0ac6323d",
  "result": {
    "markdown": "---\ntitle: \"Difference of normals is normal\"\nauthor: \"Andrew MacDonald\"\ndescription: |\n  Calculating something like growth with measurement error.\ndate: 3 May 2024\neditor: source\ncategories: [probability, likelihood]\nknitr:\n  opts_chunk: \n    warning: false\n    message: false\n    eval: false\n---\n\n\n\n\n\nTaken from the single-random-effect exercise! \n\nuses two random effects though\n\n\n## Bernoulli presence-absence data: Mite occurrance.\n\n**Which mite species are found in which site?**\n\nLet's begin by drawing a classic picture: a species by site matrix!\n\n### Visualizing \n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numbers <- with(mite_data_long,\n                        setNames(seq_along(unique(spp)), unique(spp)))\n\nmite_data_groupID <- mutate(mite_data_long,\n                            group_id = species_numbers[spp])\n\n \nmite_list <- with(mite_data_groupID,\n                  list(\n                    N = length(abd),\n                    y = abd,\n                    Ngroup = dplyr::n_distinct(spp),\n                    group_id = group_id\n                  ))\n\n\nmite_long_pa <- mite_data_groupID |> \n  mutate(pa = as.numeric(abd > 0))\n\nmite_long_pa |> \n  mutate(\n    spp = forcats::fct_reorder(spp, pa),\n    site_id = forcats::fct_reorder(site_id, pa),\n    pa = as.character(pa)) |>\n  ggplot(aes(x = site_id, y = spp, fill = pa)) + \n  geom_tile() + \n  scale_fill_manual(values = c(\"1\" = \"black\", \"0\" = \"white\")) + \n  coord_fixed()\n```\n:::\n\n\n### Mathematics\n\n$$\n\\begin{align}\n\\text{Pr(y = 1)} &\\sim \\text{Bernoulli}(p) \\\\\n\\text{logit}(p) &= \\bar\\beta + \\beta_{\\text{site}[i]} + \\beta_{\\text{species}[i]} \\\\\n\\bar\\beta &\\sim N(0,.5) \\\\\n\\beta_{\\text{site}} &\\sim N(0, .2) \\\\\n\\beta_{\\text{species}} &\\sim N(0, \\sigma_{\\text{spp}}) \\\\\n\\sigma_{\\text{spp}} &\\sim \\text{Exponential}(2)\n\\end{align}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_spp_site <- cmdstan_model(stan_file = \"topics/03_one_random_effect/bernoulli_spp_site.stan\")\n\nbernoulli_spp_site\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_mite_spp <- bernoulli_spp_site$sample(data = list(\n  N = nrow(mite_long_pa),\n  y = mite_long_pa$pa,\n  Nsite = max(as.numeric(mite_long_pa$site_id)),\n  site_id = as.numeric(mite_long_pa$site_id),\n  Nspp = max(mite_long_pa$group_id),\n  spp_id = mite_long_pa$group_id\n),parallel_chains = 2, refresh = 0, chains = 2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidybayes::get_variables(bernoulli_mite_spp)\n```\n:::\n\n\nThis model can produce a probability that any species occurs in any plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_occ_prob_logit <- bernoulli_mite_spp |> \n  tidybayes::gather_rvars(prob_occurence[spp_id, site_id])\n\n## transform into probabilities\nmite_occ_prob <- mite_occ_prob_logit |> \n  mutate(prob = posterior::rfun(plogis)(.value))\n\nmite_occ_prob |> \n  mutate(med_prob = median(prob),\n         spp_id  = forcats::fct_reorder(as.factor(spp_id), med_prob),\n         site_id = forcats::fct_reorder(as.factor(site_id), med_prob)) |> \n  ggplot(aes(x = spp_id, y = site_id, fill = med_prob)) + \n  geom_tile()\n```\n:::\n\n\n### Exercises:\n\n1. How could you assess this model fit to data? What kind of figure would be most interesting?\n1. The probability of a species occurring across all sites is given by `b_avg + b_spp`. How does that compare to the fraction of sites at which any species was observed?\n1. The expected species richness of each site is given by `b_avg + b_site`. How does that compare to the observed species richness?\n\n\n\n## Poisson random intercepts: Mite abundance\n\n**How does mite abundance vary among sites?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_long |> \n  mutate(site_id = forcats::fct_reorder(site_id, abd)) |> \n  ggplot(aes(y = site_id, x = abd)) +\n  geom_point() + \n  coord_cartesian(xlim = c(0,100)) + \n  stat_summary(fun = median, col = \"red\", geom = \"point\")\n```\n:::\n\n\n:::{.callout-tip}\n### write the model in the same notation as the original\n\nLet's model the counts of species abundances, using a random effect for each site. Write the model that corresponds to this!\n\n:::\n\n\n### Trying it with a Normal distribution:\n\nIt's actually possible to run the previous model on this one.\nlet's set up the data and try:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numbers <- with(mite_data_long,\n     setNames(seq_along(unique(spp)), unique(spp)))\n\nmite_data_groupID <- mutate(mite_data_long,\n                            group_id = species_numbers[spp])\n\nmite_list <- with(mite_data_groupID,\n                  list(\n                    N = length(abd),\n                    y = abd,\n                    Ngroup = dplyr::n_distinct(spp),\n                    group_id = group_id\n                  ))\n\nnormal_samples <- hierarchical_groups$sample(data = mite_list, refresh = 0, parallel_chains = 4)\n```\n:::\n\n\nThis is interesting, but it would probably be better to fit this model with something meant for counts! With this comes the need to include a log link function. Fortunately, Stan makes all this possible with just a few small changes:\n\n### Exercise: translate it into Stan\n\nModify the program `hierarchical_groups.stan` to work for poisson data. Some things to keep in mind: \n\n* `data {}` block: remember that the Poisson distribution needs integers and set up the data inputs accordinly.\n* `parameters {}` block: think about which parameters the poisson does NOT need. \n* `model {}` block: remember to remove any unneeded parameters from the likelihood (the model of the data), and their priors too.\n* replace `normal` with `poisson_log`. Note that this evaluates its argument on the log scale. That is, it works like a typical GLM done in R. We can keep priors the same as in the last model, though we may decide to change their values.\n* `generated quantities {}` block: replace `normal_rng()` with `poisson_log_rng()` -- _where necessary_ -- and delete unused parameters.\n* again, remember that the Poisson needs to be making integers. For example, replace `vector[Ngroup]` with `array[Ngroup] int `\n\n\n\n\n\n### Exercises\n\n* Try modifying the program again, this time adding a predictor: water content. What happens to `sigma_grp` in this example?\n\n\n\n## Extra stuff\n\nLet's use simulations to demonstrate that univariate normal distributions are special cases of multivariate normal distributions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmysigma <- 3\nnsamp <- 1100\n\nhist(rnorm(nsamp, 0, mysigma))\n\nmySigma <- diag(mysigma, nrow = nsamp)\n\nmv_numbers <- MASS::mvrnorm(1, mu = rep(0, nsamp), Sigma = mySigma)\nhist(mv_numbers)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}