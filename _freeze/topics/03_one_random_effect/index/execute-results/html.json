{
  "hash": "f3cc07add4ed6e27d7bdde89e5f9f549",
  "result": {
    "markdown": "---\ntitle: \"Models with one level of hierarchy\"\ndescription: |\n  Some of these things are somewhat like the others.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\n---\n\n\n\n:::{.callout-tip}\n## Bayesian workflow\n\n1. Visualize your data\n2. Decide on your model structure\n3. Simulate from the model to understand it\n4. Fit the model to the data\n5. Plot model predictions to evaluate the fit / draw conclusions\n:::\n\nToday's goal is to look at a couple of different model structures that we saw yesterday. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is cmdstanr version 0.5.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan path: /Users/amacdonald/.cmdstan/cmdstan-2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan version: 2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable CMDSTANR_NO_VER_CHECK=TRUE.\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidybayes)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n## Gaussian random intercepts: Penguin body mass\n\nThe Palmer penguins are found on three different islands. Let's look at the distribution of body mass of each species on each island.\n\n### Plot the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island <- penguins |> \n  select(species, island, body_mass_g) |> \n  drop_na(body_mass_g) |> \n  unite(sp_island, species, island) |> \n  ## center mass and change the units\n  mutate(mass_kg = (body_mass_g)/1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  ggplot(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gauss-inter-plot-1.png){width=672}\n:::\n:::\n\n\nAre the sample sizes equal among the species-island combinations?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  count(sp_island) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|sp_island        |   n|\n|:----------------|---:|\n|Adelie_Biscoe    |  44|\n|Adelie_Dream     |  56|\n|Adelie_Torgersen |  51|\n|Chinstrap_Dream  |  68|\n|Gentoo_Biscoe    | 123|\n:::\n:::\n\n\n### Decide on a model structure\n\nWe'll begin by fitting a model that assumes that body size for each of these five groups is completely independent:\n\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{species}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{species}} &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma &\\sim \\text{Exponential}(.5)\n\\end{align}\n$$\n\n### Simulate to understand this model\n\nHere's a little trick to get group indexes (numbers) from a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_names <- unique(penguin_mass_island$sp_island)\ngroup_numbers <- seq_along(group_names)\nnames(group_numbers) <- group_names\n\ngroup_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdelie_Torgersen    Adelie_Biscoe     Adelie_Dream    Gentoo_Biscoe \n               1                2                3                4 \n Chinstrap_Dream \n               5 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_groupid <- penguin_mass_island |> \n  mutate(group_id = group_numbers[sp_island])\n\npenguin_groupid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 342 × 4\n   sp_island        body_mass_g mass_kg group_id\n   <chr>                  <int>   <dbl>    <int>\n 1 Adelie_Torgersen        3750    3.75        1\n 2 Adelie_Torgersen        3800    3.8         1\n 3 Adelie_Torgersen        3250    3.25        1\n 4 Adelie_Torgersen        3450    3.45        1\n 5 Adelie_Torgersen        3650    3.65        1\n 6 Adelie_Torgersen        3625    3.62        1\n 7 Adelie_Torgersen        4675    4.68        1\n 8 Adelie_Torgersen        3475    3.48        1\n 9 Adelie_Torgersen        4250    4.25        1\n10 Adelie_Torgersen        3300    3.3         1\n# ℹ 332 more rows\n```\n:::\n:::\n\n\nAs you can see, we're set up now with the names and the indexes we need. \n\nNow we can simulate data and plot it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nngroup <- length(group_numbers)\noverall_mean <- rnorm(1, mean = 5, sd = 2)\ngroup_diffs <- rnorm(n = ngroup, mean = 0, sd = 1)\nsigma_obs <- rexp(1, .5)\n\npenguin_pred_obs <- penguin_groupid |> \n  mutate(fake_mass_avg = overall_mean + group_diffs[group_id],\n         fake_mass_obs = rnorm(length(fake_mass_avg), \n                               mean = fake_mass_avg, \n                               sd = sigma_obs))\n\npenguin_pred_obs |> \n  ggplot(aes(y = sp_island,\n             x = fake_mass_obs,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-tip}\nrun the above code a few times! if you want, try different prior values.\n:::\n\n### Write it in Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/fixed_groups.stan\")\n\nfixed_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma);\n  b_group ~ std_normal();\n  b_avg ~ normal(5, 2);\n  sigma ~ exponential(.5);\n}\ngenerated quantities {\n  vector[N] fake_obs;\n  \n  for (i in 1:N) {\n    fake_obs[i] = normal_rng(b_avg + b_group[group_id[i]], sigma);\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(b_avg + b_group[k], sigma);\n  }\n}\n```\n:::\n:::\n\n\n### Fit the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_group_list <- with(penguin_groupid, \n         list(\n           N = length(mass_kg),\n           y = mass_kg,\n           Ngroup = max(group_id),\n           group_id = group_id\n         ))\n\nfixed_groups_samples <- fixed_groups$sample(\n  data = peng_group_list,\n  refresh = 0,\n  parallel_chains = 4\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpYROeSn/model-15c466a4b69e9.stan', line 13, column 2 to column 47)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 1.6 seconds.\nChain 2 finished in 1.7 seconds.\nChain 3 finished in 1.8 seconds.\nChain 4 finished in 1.7 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.7 seconds.\nTotal execution time: 2.0 seconds.\n```\n:::\n:::\n\n\n### Plot predictions to evaluate results\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## bayesplot\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id]) |> \n  mutate(sp_island = group_names[group_id]) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval() + \n  geom_point(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island), \n             inherit.aes = FALSE,\n             alpha = .2, data = penguin_groupid)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using the `size` aesthetic with geom_segment was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n### Make it hierarchical\n\nTK make them side by side\n\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{species}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{species}} &\\sim \\text{Normal}(0, \\sigma_{\\text{sp}}) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5) \\\\\n\\sigma_{\\text{sp}} &\\sim \\text{Exponential}(1)\n\\end{align}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/hierarchical_groups.stan\")\n\nhierarchical_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma_obs;\n  real<lower=0> sigma_grp;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma_obs);\n  b_group ~ normal(0, sigma_grp);\n  b_avg ~ normal(5, 2);\n  sigma_obs ~ exponential(.5);\n  sigma_grp ~ exponential(1);\n}\ngenerated quantities {\n  vector[N] fake_obs;\n  \n  for (i in 1:N) {\n    fake_obs[i] = normal_rng(b_avg + b_group[group_id[i]], sigma_obs);\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(b_avg + b_group[k], sigma_obs);\n  }\n  \n  // difference for a new group\n  real new_b_group = normal_rng(0, sigma_grp);\n  \n  // observations from that new group\n  real one_obs_new_group = normal_rng(b_avg + new_b_group, sigma_obs);\n  \n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples <- hierarchical_groups$sample(\n  data = peng_group_list, refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpYROeSn/model-15c46a09925.stan', line 14, column 2 to column 51)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 1.8 seconds.\nChain 3 finished in 1.7 seconds.\nChain 2 finished in 1.8 seconds.\nChain 4 finished in 1.8 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.8 seconds.\nTotal execution time: 2.0 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n lp__        88.56  88.87 2.01 1.89 84.71 91.20 1.01     1167     2080\n b_avg        4.00   3.99 0.32 0.28  3.50  4.56 1.01      755      828\n b_group[1]  -0.29  -0.28 0.32 0.29 -0.85  0.21 1.01      768      902\n b_group[2]  -0.29  -0.28 0.32 0.29 -0.84  0.21 1.01      774      829\n b_group[3]  -0.31  -0.30 0.32 0.29 -0.86  0.20 1.01      772      856\n b_group[4]   1.07   1.08 0.32 0.28  0.52  1.57 1.01      762      841\n b_group[5]  -0.27  -0.26 0.32 0.29 -0.83  0.23 1.01      757      848\n sigma_obs    0.47   0.46 0.02 0.02  0.44  0.50 1.00     1755     1956\n sigma_grp    0.75   0.67 0.31 0.23  0.41  1.35 1.00     1154     1390\n fake_obs[1]  3.72   3.71 0.47 0.47  2.95  4.50 1.00     3843     3664\n\n # showing 10 of 358 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(b_group[group_id],\n                          new_b_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id],\n                          one_obs_new_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval() + \n  geom_point(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island), \n             inherit.aes = FALSE,\n             alpha = .2, data = penguin_groupid)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Exercises\n\n1. Try leaving out a group and refitting the hierarchical model. Are the predictions for the missing group accurate?\n1. There are other categorical predictors in the dataset. Try including `year` as a part of the group-creating factor (i.e. in the call to `unite()` above). What changes?\n1. The posterior for both models includes a predicted `fake_obs` for EVERY observation. This opens the possibility of using `bayesplot` to make predictions. Look back at the code from Day 1 and create a posterior predictive check for both models. (e.g. using `ppc_dens_overlay`)\n1. We could perhaps have used `sex` as a grouping factor, but `sex` has missing values in it! Why is this a problem for this kind of model? What would it take to address that? (Discussion only; missing values are unfortunately outside the class scope!)\n\n## Poisson random intercepts: Mite abundance\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\n\n# combine data and environment\n\nmite_data_long <- mite |> \n  tibble::rownames_to_column(var = \"site_id\") |> \n  bind_cols(mite.env) |> \n  pivot_longer(Brachy:Trimalc2,\n               names_to = \"spp\", values_to = \"abd\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_long |> \n  mutate(site_id = forcats::fct_reorder(site_id, abd)) |> \n  ggplot(aes(y = site_id, x = abd)) +\n  geom_point() + \n  coord_cartesian(xlim = c(0,100)) + \n  stat_summary(fun = median, col = \"red\", geom = \"point\")\n```\n\n::: {.cell-output-display}\n![Abundance of each species at every site in the mite dataset. Points are species abundances, grouped on the row for that site.](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n### Exercise: write the model in the same notation as the original\n\nLet's model the counts of species abundances, using a random effect for each site. Write the model that corresponds to this!\n\n### Trying it with a Normal distribution:\n\nIt's actually possible to run the previous model on this one.\nlet's set up the data and try:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numbers <- with(mite_data_long,\n     setNames(seq_along(unique(spp)), unique(spp)))\n\nmite_data_groupID <- mutate(mite_data_long,\n                            group_id = species_numbers[spp])\n\nmite_list <- with(mite_data_groupID,\n                  list(\n                    N = length(abd),\n                    y = abd,\n                    Ngroup = dplyr::n_distinct(spp),\n                    group_id = group_id\n                  ))\n\nnormal_samples <- hierarchical_groups$sample(data = mite_list, refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 4 finished in 9.8 seconds.\nChain 1 finished in 10.2 seconds.\nChain 3 finished in 10.1 seconds.\nChain 2 finished in 10.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 10.1 seconds.\nTotal execution time: 10.4 seconds.\n```\n:::\n:::\n\n\nThis is interesting, but it would probably be better to fit this model with something meant for counts! With this comes the need to include a log link function. Fortunately, Stan makes all this possible with just a few small changes:\n\n### Exercise: translate it into Stan\n\nModify the program `hierarchical_groups.stan` to work for poisson data. Some things to keep in mind: \n\n* `data {}` block: remember that the Poisson distribution needs integers and set up the data inputs accordinly.\n* `parameters {}` block: think about which parameters the poisson does NOT need. \n* `model {}` block: remember to remove any unneeded parameters from the likelihood (the model of the data), and their priors too.\n* replace `normal` with `poisson_log`. Note that this evaluates its argument on the log scale. That is, it works like a typical GLM done in R. We can keep priors the same as in the last model, though we may decide to change their values.\n* `generated quantities {}` block: replace `normal_rng()` with `poisson_log_rng()` -- _where necessary_ -- and delete unused parameters.\n* again, remember that the Poisson needs to be making integers. For example, replace `vector[Ngroup]` with `array[Ngroup] int `\n\n\n\n\n\n### Exercises\n\n* Try modifying the program again, this time adding a predictor: water content. What happens to `sigma_grp` in this example?\n\n## Observation-level random effects: Mite species richness\n\nFirst let's transform the mite dataset into a dataframe of species richness per site. We'll also standardize the water content while we're at it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_species_richness <- mite_data_long |> \n  group_by(site_id, WatrCont) |> \n  summarize(S = sum(abd > 0)) |>\n  ungroup() |> \n  mutate(water_c = (WatrCont - mean(WatrCont))/100)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'site_id'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nhead(mite_species_richness)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  site_id WatrCont     S water_c\n  <chr>      <dbl> <int>   <dbl>\n1 1           350.    20 -0.605 \n2 10          221.    19 -1.90  \n3 11          134.    25 -2.77  \n4 12          406.    19 -0.0473\n5 13          244.    18 -1.67  \n6 14          240.    23 -1.71  \n```\n:::\n:::\n\n\nWe get a nice histogram of species richness, and a clear negative relationship with water volume:\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nmite_species_richness |> \n  ggplot(aes(x = S)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmite_species_richness |> \n  ggplot(aes(x = water_c, y = S)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n### Exercises\n\n1. The mean species richness is about 15 species. Simulate from a poisson distribution with this mean. Does it look like the figure above?\n1. Use Rstudio to make a new Stan file. This model is set up to estimate a normal distribution. Modify it so that it works for a Poisson instead, and fit it to the species richness data.\n1. Validate that model with a figure of your choosing. Does it work well?\n1. Add a random effect for every site in the dataset. This is called an **observation-level random effect** and can be a very convenient way to work with overdispersion.\n1. Try modifying the Poisson model above to include a predictor. Write this model out in math first! \n1. Use this model to draw a expected (and/or a prediction) line through the second figure above.\n\n\n## Bernoulli presence-absence data: Mite occurrance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_long_pa <- mite_data_groupID |> \n  mutate(pa = as.numeric(abd > 0))\n\nmite_long_pa |> \n  mutate(\n    spp = forcats::fct_reorder(spp, pa),\n    site_id = forcats::fct_reorder(site_id, pa),\n    pa = as.character(pa)) |>\n  ggplot(aes(x = site_id, y = spp, fill = pa)) + \n  geom_tile() + \n  scale_fill_manual(values = c(\"1\" = \"black\", \"0\" = \"white\")) + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n$$\n\\begin{align}\n\\text{Pr(y = 1)} &\\sim \\text{Bernoulli}(p) \\\\\n\\text{logit}(p) &= \\bar\\beta + \\beta_{\\text{site}[i]} + \\beta_{\\text{species}[i]} \\\\\n\\bar\\beta &\\sim N(0,.5) \\\\\n\\beta_{\\text{site}} &\\sim N(0, .2) \\\\\n\\beta_{\\text{species}} &\\sim N(0, \\sigma_{\\text{spp}}) \\\\\n\\sigma_{\\text{spp}} &\\sim \\text{Exponential}(2)\n\\end{align}\n$$\n\n\n```{=html}\n <iframe id=\"example1\" src=\"https://aammd.shinyapps.io/study_shiny_modules/?_ga=2.251710607.740679894.1683719385-420118587.1683719385\" style=\"border: none; width: 100%; height: 720px\" frameborder=\"0\"></iframe>\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nbrms::brm(pa ~ 1 + site_id + (1 | spp), family = \"bernoulli\", data= mite_long_pa)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_spp_site <- cmdstan_model(stan_file = \"topics/03_one_random_effect/bernoulli_spp_site.stan\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_mite_spp <- bernoulli_spp_site$sample(data = list(\n  N = nrow(mite_long_pa),\n  y = mite_long_pa$pa,\n  Nsite = max(as.numeric(mite_long_pa$site_id)),\n  site_id = as.numeric(mite_long_pa$site_id),\n  Nspp = max(mite_long_pa$group_id),\n  spp_id = mite_long_pa$group_id\n),parallel_chains = 2, refresh = 0, chains = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 2 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/var/folders/x7/l08zn2396g797m5ws54np_6w0000gp/T/RtmpZSIOvZ/model-165a421575591.stan', line 18, column 2 to column 31)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 11.1 seconds.\nChain 2 finished in 11.1 seconds.\n\nBoth chains finished successfully.\nMean chain execution time: 11.1 seconds.\nTotal execution time: 11.2 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidybayes::get_variables(bernoulli_mite_spp)\n```\n:::\n\n\nThis model can produce a probability that any species occurs in any plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_occ_prob_logit <- bernoulli_mite_spp |> \n  tidybayes::gather_rvars(prob_occurence[spp_id, site_id])\n\n## transform into probabilities\nmite_occ_prob <- mite_occ_prob_logit |> \n  mutate(prob = posterior::rfun(plogis)(.value))\n\nmite_occ_prob |> \n  mutate(med_prob = median(prob),\n         spp_id  = forcats::fct_reorder(as.factor(spp_id), med_prob),\n         site_id = forcats::fct_reorder(as.factor(site_id), med_prob)) |> \n  ggplot(aes(x = spp_id, y = site_id, fill = med_prob)) + \n  geom_tile()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n### Exercises:\n\n1. How could you assess this model fit to data? What kind of figure would be most interesting?\n1. The probability of a species occurring across all sites is given by `b_avg + b_spp`. How does that compare to the fraction of sites at which any species was observed?\n1. The expected species richness of each site is given by `b_avg + b_site`. How does that compare to the observed species richness?",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}