{
  "hash": "f55818f1cbf8f694d58c3649deba4ffa",
  "result": {
    "markdown": "---\ntitle: \"Models with one level of hierarchy\"\ndescription: |\n  Some of these things are somewhat like the others.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n:::{.callout-tip}\n## Bayesian workflow\n\n1. Visualize your data\n2. Decide on your model structure\n3. Simulate from the model to understand it\n4. Fit the model to the data\n5. Plot model predictions to evaluate the fit / draw conclusions\n:::\n\nToday's goal is to look at a couple of different model structures that we saw yesterday. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is cmdstanr version 0.7.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan path: /home/andrew/software/cmdstan\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan version: 2.34.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidybayes)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n## Gaussian random intercepts: Penguin body mass\n\n**Are populations of penguins on different islands different in their body mass?**\n\nThe Palmer penguins are found on three different islands. Let's look at the distribution of body mass of each species on each island.\n\n### Plot the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island <- penguins |> \n  select(species, island, body_mass_g) |> \n  drop_na(body_mass_g) |> \n  unite(sp_island, species, island) |> \n  ## center mass and change the units\n  mutate(mass_kg = (body_mass_g)/1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  ggplot(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gauss-inter-plot-1.png){width=672}\n:::\n:::\n\n\nAre the sample sizes equal among the species-island combinations?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  count(sp_island) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|sp_island        |   n|\n|:----------------|---:|\n|Adelie_Biscoe    |  44|\n|Adelie_Dream     |  56|\n|Adelie_Torgersen |  51|\n|Chinstrap_Dream  |  68|\n|Gentoo_Biscoe    | 123|\n:::\n:::\n\n\n### Decide on a model structure\n\nWe'll begin by fitting a model that assumes that body size for each of these five groups is completely independent:\n\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5)\n\\end{align}\n$$\n\n### Simulate to understand this model {#sec-fixed-simulation}\n\nHere's a little trick to get group indexes (numbers) from a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_names <- unique(penguin_mass_island$sp_island)\ngroup_numbers <- seq_along(group_names)\nnames(group_numbers) <- group_names\n\ngroup_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdelie_Torgersen    Adelie_Biscoe     Adelie_Dream    Gentoo_Biscoe \n               1                2                3                4 \n Chinstrap_Dream \n               5 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_groupid <- penguin_mass_island |> \n  mutate(group_id = group_numbers[sp_island])\n\npenguin_groupid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 342 × 4\n   sp_island        body_mass_g mass_kg group_id\n   <chr>                  <int>   <dbl>    <int>\n 1 Adelie_Torgersen        3750    3.75        1\n 2 Adelie_Torgersen        3800    3.8         1\n 3 Adelie_Torgersen        3250    3.25        1\n 4 Adelie_Torgersen        3450    3.45        1\n 5 Adelie_Torgersen        3650    3.65        1\n 6 Adelie_Torgersen        3625    3.62        1\n 7 Adelie_Torgersen        4675    4.68        1\n 8 Adelie_Torgersen        3475    3.48        1\n 9 Adelie_Torgersen        4250    4.25        1\n10 Adelie_Torgersen        3300    3.3         1\n# ℹ 332 more rows\n```\n:::\n:::\n\n\nAs you can see, we're set up now with the names and the indexes we need. \n\nNow we can simulate data and plot it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nngroup <- length(group_numbers)\noverall_mean <- rnorm(1, mean = 5, sd = 2)\ngroup_diffs <- rnorm(n = ngroup, mean = 0, sd = 1)\nsigma_obs <- rexp(1, .5)\n\npenguin_pred_obs <- penguin_groupid |> \n  mutate(fake_mass_avg = overall_mean + group_diffs[group_id],\n         fake_mass_obs = rnorm(length(fake_mass_avg), \n                               mean = fake_mass_avg, \n                               sd = sigma_obs))\n\npenguin_pred_obs |> \n  ggplot(aes(y = sp_island,\n             x = fake_mass_obs,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-tip}\n### EXERCISE\nRun the above code a few times! if you want, try different prior values.\n:::\n\n### Write it in Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/fixed_groups.stan\")\n\nfixed_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma);\n  b_group ~ std_normal();\n  b_avg ~ normal(5, 2);\n  sigma ~ exponential(.5);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma);\n  }\n}\n```\n:::\n:::\n\n\n### Fit the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_group_list <- with(penguin_groupid, \n         list(\n           N = length(mass_kg),\n           y = mass_kg,\n           Ngroup = max(group_id),\n           group_id = group_id\n         ))\n\nfixed_groups_samples <- fixed_groups$sample(\n  data = peng_group_list,\n  refresh = 0,\n  parallel_chains = 4\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.3 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 0.4 seconds.\n```\n:::\n:::\n\n\n### Plot predictions to evaluate results\n\n\nLet's begin by plotting the averages for each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups_samples |> \n  gather_rvars(group_averages[group_id]) |> \n  mutate(sp_island = names(group_numbers)[group_id]) |> \n  ggplot(aes(y = sp_island, dist = .value)) + \n  stat_pointinterval() + \n  geom_jitter(data = penguin_mass_island,\n              aes(y = sp_island,\n                  x = mass_kg,\n                  colour = sp_island), \n              pch = 21, inherit.aes = FALSE,\n              alpha = 0.8, height = 0.1, width = 0) + \n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nSome things to notice about the code above: \n\n* I'm using my named vector `group_numbers` to re-create the column `sp_island`. This is my technique for making sure I always use the correct label, but you can do this any way you want.\n* We use `tidybayes::stat_pointinterval()` to summarize the posterior distribution.\n* we're adding points from the original data (`penguin_mass_island`) with `geom_jitter()`. We're adding noise vertically to make the visualization better, but not adding any horizontal noise.\n\n:::{.callout-tip}\n### EXERCISE: plot posterior predictions of _observations_\n\nRepeat the exercise above using the value of `one_obs_per_group`. \nWhy are the results different? What additional error is included in these predictions?\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id]) |> \n  mutate(sp_island = group_names[group_id]) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval(colour = \"black\") + \n  geom_jitter(\n    aes(y = sp_island,\n        x = mass_kg,\n        colour = sp_island), \n    inherit.aes = FALSE,\n    alpha = .2, data = penguin_groupid, height = .2, width = 0) + \n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n:::\n\n### Make it hierarchical\n\n#### Math\n\n\n:::{.column-screen}\n\n::::{.columns}\n\n::: {.column width=\"2.5%\"}\n:::\n\n::: {.column width=\"45%\"}\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5)\n\\end{align}\n$$\n:::\n\n::: {.column width=\"5%\"}\n\n:::\n\n::: {.column width=\"45%\"}\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, \\sigma_{\\text{sp}}) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5) \\\\\n\\sigma_{\\text{sp}} &\\sim \\text{Exponential}(1)\n\\end{align}\n$$\n\n:::\n\n::: {.column width=\"2.5%\"}\n\n:::\n\n::::\n\n:::\n\n#### Simulation of a hierarchical model\n\n:::{.callout-tip}\n### EXERCISE \nSimulate from the model above. Base your approach on the [code for simulation the non-hierarchical version](#sec-fixed-simulation). \nRemember to simulate one additional number: the standard deviation of group differences\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n::: {.cell}\n\n```{.r .cell-code}\nngroup <- length(group_numbers)\noverall_mean <- rnorm(1, mean = 5, sd = 2)\nsigma_group <- rexp(1, .1)\ngroup_diffs <- rnorm(n = ngroup, mean = 0, sd = sigma_group)\nsigma_obs <- rexp(1, .5)\n\npenguin_pred_obs <- penguin_groupid |> \n  mutate(fake_mass_avg = overall_mean + group_diffs[group_id],\n         fake_mass_obs = rnorm(length(fake_mass_avg), \n                               mean = fake_mass_avg, \n                               sd = sigma_obs))\n\npenguin_pred_obs |> \n  ggplot(aes(y = sp_island,\n             x = fake_mass_obs,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n:::\n\n#### Stan\n\n\nBelow I'm comparing the two Stan programs side-by-side. Compare them to the models above! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/hierarchical_groups.stan\")\n```\n:::\n\n\n:::{.column-screen}\n\n::::{.columns}\n\n::: {.column width=\"2.5%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma);\n  b_group ~ std_normal();\n  b_avg ~ normal(5, 2);\n  sigma ~ exponential(.5);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma);\n  }\n}\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"5%\"}\n\n:::\n\n::: {.column width=\"45%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma_obs;\n  real<lower=0> sigma_grp;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma_obs);\n  b_group ~ normal(0, sigma_grp);\n  b_avg ~ normal(5, 2);\n  sigma_obs ~ exponential(.5);\n  sigma_grp ~ exponential(1);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma_obs);\n  }\n  \n  // difference for a new group\n  real new_b_group = normal_rng(0, sigma_grp);\n  \n  // observations from that new group\n  real one_obs_new_group = normal_rng(b_avg + new_b_group, sigma_obs);\n  \n}\n```\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"2.5%\"}\n\n:::\n\n::::\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples <- hierarchical_groups$sample(\n  data = peng_group_list, refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpWhWKuf/model-473001618f1b5.stan', line 15, column 2 to column 33)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 0.4 seconds.\nChain 2 finished in 0.4 seconds.\nChain 3 finished in 0.4 seconds.\nChain 4 finished in 0.4 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.4 seconds.\nTotal execution time: 0.5 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n lp__              88.43  88.77 2.05 1.91 84.44 91.20 1.00     1348     2221\n b_avg              4.01   4.00 0.35 0.30  3.42  4.57 1.01      557      481\n b_group[1]        -0.30  -0.30 0.36 0.31 -0.88  0.31 1.01      545      510\n b_group[2]        -0.29  -0.29 0.36 0.30 -0.87  0.30 1.01      607      512\n b_group[3]        -0.31  -0.31 0.36 0.31 -0.89  0.27 1.00      560      516\n b_group[4]         1.07   1.07 0.36 0.30  0.49  1.66 1.00      541      486\n b_group[5]        -0.27  -0.27 0.36 0.31 -0.84  0.32 1.01      542      481\n sigma_obs          0.47   0.46 0.02 0.02  0.44  0.50 1.00     1346     1739\n sigma_grp          0.76   0.69 0.32 0.26  0.41  1.38 1.00     1401     1294\n group_averages[1]  3.71   3.71 0.06 0.06  3.60  3.82 1.00     4302     3121\n\n # showing 10 of 21 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(b_group[group_id],\n                          new_b_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id],\n                          one_obs_new_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval() + \n  geom_point(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island), \n             inherit.aes = FALSE,\n             alpha = .2, data = penguin_groupid)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n## Exercises\n\n1. Try leaving out a group and refitting the hierarchical model. Are the predictions for the missing group accurate?\n1. There are other categorical predictors in the dataset. Try including `year` as a part of the group-creating factor (i.e. in the call to `unite()` above). What changes?\n1. The posterior for both models includes a predicted `fake_obs` for EVERY observation. This opens the possibility of using `bayesplot` to make predictions. Look back at the code from Day 1 and create a posterior predictive check for both models. (e.g. using `ppc_dens_overlay`)\n1. We could perhaps have used `sex` as a grouping factor, but `sex` has missing values in it! Why is this a problem for this kind of model? What would it take to address that? (Discussion only; missing values are unfortunately outside the class scope!)\n\n## Observation-level random effects: Mite abundance\n\n### What is the question? \n\nLet's write a model to answer the question:  \n\n**How does the total abundance of the mite community change as water content increases?**  \n\n### Express this in Math\n\nHere's a partially complete model for species richness over time\n\n$$\n\\begin{align}\n\\text{S}_i &\\sim \\text{Poisson}(e^a) \\\\\na &= \\bar\\beta + \\beta_{\\text{water}} \\cdot \\text{water}_i \\\\\n\\bar\\beta &\\sim \\text{Normal}(?, ?) \\\\\n\\beta_{\\text{water}} &\\sim \\text{Normal}(?, ?) \\\\\n\\end{align}\n$$\n\n:::{.callout-tip}\n### EXERCISE \nSimulate from this model, and look at your simulations to decide on a reasonable prior for the data.\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 30\nwater <- seq(from = -5, to = 5, length.out = n)\n\nb0 <- rnorm(1, mean = log(17), sd = .3)\nb1 <- rnorm(1, mean = 0, sd = .2)\n\nS <- rpois(n, lambda = exp(b0 + b1*water))\nplot(water, S)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n:::\n\n### Data preparation & visualization\n\nFirst we need to load and prepare the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\n\n# combine data and environment\n\nmite_data_long <- mite |> \n  tibble::rownames_to_column(var = \"site_id\") |> \n  bind_cols(mite.env) |> \n  pivot_longer(Brachy:Trimalc2,\n               names_to = \"spp\", values_to = \"abd\")\n```\n:::\n\n\n\nFirst let's transform the mite dataset into a dataframe of species richness per site. \nWe'll also standardize the water content while we're at it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_species_richness <- mite_data_long |> \n  group_by(site_id, WatrCont) |> \n  summarize(S = sum(abd)) |>\n  ungroup() |> \n  mutate(water_c = (WatrCont - mean(WatrCont))/100)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'site_id'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nhead(mite_species_richness)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  site_id WatrCont     S water_c\n  <chr>      <dbl> <int>   <dbl>\n1 1           350.   140 -0.605 \n2 10          221.   166 -1.90  \n3 11          134.   216 -2.77  \n4 12          406.   213 -0.0473\n5 13          244.   177 -1.67  \n6 14          240.   269 -1.71  \n```\n:::\n:::\n\n\nWe get a nice histogram of species richness, and a clear negative relationship with water volume:\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nmite_species_richness |> \n  ggplot(aes(x = S)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmite_species_richness |> \n  ggplot(aes(x = water_c, y = S)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n:::\n\n\n### Write the model in Stan and estimate it\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_regression <- cmdstan_model(stan_file = \"topics/03_one_random_effect/poisson_regression.stan\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwater_for_pred <- seq(from = -3, to = 4.5, length.out = 15)\n\nabd_data_list <- list(N = length(mite_species_richness$S),\n              water = mite_species_richness$water_c,\n              y = mite_species_richness$S,\n              Npred = 15,\n              water_pred = water_for_pred)\n\npoisson_regression_sample <- poisson_regression$sample(\n  data = abd_data_list,\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.5 seconds.\n```\n:::\n:::\n\n\n### Plot the model to see if it fits well\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\npoisson_regression_sample |> \n  tidybayes::gather_rvars(line_obs[i]) |> \n  mutate(water = water_for_pred) |> \n  ggplot(aes(x = water, dist = .value)) + \n  stat_lineribbon() + \n  geom_point(aes(x = water_c, y = S), data = mite_species_richness, inherit.aes = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\nfake_obs_S <- poisson_regression_sample$draws(variables = \"fake_obs\")\nfake_obs_S_matrix <- posterior::as_draws_matrix(fake_obs_S)\n\nbayesplot::ppc_dens_overlay(y = mite_species_richness$S,\n                            yrep = head(fake_obs_S_matrix, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-2.png){width=672}\n:::\n:::\n\n\n\n:::{.callout-tip\n### EXERCISE\n1) Add a random effect for _every individual observation_ in the model. Begin by writing the mathematical notation for this new model! \n\n2) fit the model and re-create the two figures above. What do you notice? \n\n* Which model is more trustworthy?\n* look at the slope in the new model. Is it different?\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n#### Mathematical notation\n\n$$\n\\begin{align}\n\\text{S}_i &\\sim \\text{Poisson}(e^a) \\\\\na &= \\bar\\beta + \\beta_{\\text{water}} \\cdot \\text{water}_i + \\text{site}_i\\\\\n\\bar\\beta &\\sim \\text{Normal}(?, ?) \\\\\n\\beta_{\\text{water}} &\\sim \\text{Normal}(?, ?) \\\\\n\\text{site} &\\sim \\text{Normal}(?, \\sigma) \\\\\n\\sigma &\\sim \\text{Exponential}(?)\n\\end{align}\n$$\n\n#### Stan code \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_regression_overdisp <- cmdstan_model(stan_file = \"topics/03_one_random_effect/poisson_regression_overdisp.stan\")\n\npoisson_regression_overdisp_sample <- poisson_regression_overdisp$sample(\n  data = abd_data_list, refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.3 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpIhvutV/model-471231bcd7800.stan', line 18, column 2 to column 42)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 2 finished in 0.3 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpIhvutV/model-471231bcd7800.stan', line 18, column 2 to column 42)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 3 finished in 0.3 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpIhvutV/model-471231bcd7800.stan', line 18, column 2 to column 42)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 1.4 seconds.\n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nfake_obs_S <- poisson_regression_overdisp_sample$draws(variables = \"fake_obs\")\nfake_obs_S_matrix <- posterior::as_draws_matrix(fake_obs_S)\n\nbayesplot::ppc_dens_overlay(y = mite_species_richness$S,\n                            yrep = head(fake_obs_S_matrix, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\npoisson_regression_overdisp_sample |> \n  tidybayes::gather_rvars(line_obs[i]) |> \n  mutate(water = water_for_pred) |> \n  ggplot(aes(x = water, dist = .value)) + \n  stat_lineribbon() + \n  geom_point(aes(x = water_c, y = S), data = mite_species_richness, inherit.aes = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n:::\n\n\n:::\n\n\n\n:::{.callout-note}\nAnother great way to model overdispersion is via the [Negative Binomial](https://en.wikipedia.org/wiki/Negative_binomial_distribution) distribution. Look at the Stan documentation for [neg_binomial_2_log](https://mc-stan.org/docs/functions-reference/neg-binom-2-log.html) and adapt your model to use it (don't forget to drop the random effect when you do!).\n:::\n\n:::{.callout-warning}\nThe code below is EXTRA material showing other examples you might be interested in! \n:::\n\n\n## Bernoulli presence-absence data: Mite occurrance.\n\n**Which mite species are found in which site?**\n\nLet's begin by drawing a classic picture: a species by site matrix!\n\n### Visualizing \n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numbers <- with(mite_data_long,\n                        setNames(seq_along(unique(spp)), unique(spp)))\n\nmite_data_groupID <- mutate(mite_data_long,\n                            group_id = species_numbers[spp])\n\n \nmite_list <- with(mite_data_groupID,\n                  list(\n                    N = length(abd),\n                    y = abd,\n                    Ngroup = dplyr::n_distinct(spp),\n                    group_id = group_id\n                  ))\n\n\nmite_long_pa <- mite_data_groupID |> \n  mutate(pa = as.numeric(abd > 0))\n\nmite_long_pa |> \n  mutate(\n    spp = forcats::fct_reorder(spp, pa),\n    site_id = forcats::fct_reorder(site_id, pa),\n    pa = as.character(pa)) |>\n  ggplot(aes(x = site_id, y = spp, fill = pa)) + \n  geom_tile() + \n  scale_fill_manual(values = c(\"1\" = \"black\", \"0\" = \"white\")) + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![A species x site matrix for the mite data.](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### Mathematics\n\n$$\n\\begin{align}\n\\text{Pr(y = 1)} &\\sim \\text{Bernoulli}(p) \\\\\n\\text{logit}(p) &= \\bar\\beta + \\beta_{\\text{site}[i]} + \\beta_{\\text{species}[i]} \\\\\n\\bar\\beta &\\sim N(0,.5) \\\\\n\\beta_{\\text{site}} &\\sim N(0, .2) \\\\\n\\beta_{\\text{species}} &\\sim N(0, \\sigma_{\\text{spp}}) \\\\\n\\sigma_{\\text{spp}} &\\sim \\text{Exponential}(2)\n\\end{align}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_spp_site <- cmdstan_model(stan_file = \"topics/03_one_random_effect/bernoulli_spp_site.stan\")\n\nbernoulli_spp_site\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  array[N] int y;\n  int<lower=0> Nsite;\n  array[N] int<lower=0, upper=Nsite> site_id;\n  int<lower=0> Nspp;\n  array[N] int<lower=0, upper=Nspp> spp_id;\n}\nparameters {\n  real b_avg;\n  vector[Nsite] b_site;\n  vector[Nspp] b_spp;\n  real<lower=0> sigma_spp;\n}\nmodel {\n  y ~ bernoulli_logit(b_avg + b_site[site_id] + b_spp[spp_id]);\n  b_spp ~ normal(0, .2);\n  b_spp ~ normal(0, sigma_spp);\n  b_avg ~ normal(0, .5);\n  sigma_spp ~ exponential(2);\n}\ngenerated quantities {\n  matrix[Nspp, Nsite] prob_occurence;\n  \n  for (i in 1:Nspp){\n    for (j in 1:Nsite) {\n      prob_occurence[i,j] = b_avg + b_site[j] + b_spp[i];\n    }\n  }\n}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_mite_spp <- bernoulli_spp_site$sample(data = list(\n  N = nrow(mite_long_pa),\n  y = mite_long_pa$pa,\n  Nsite = max(as.numeric(mite_long_pa$site_id)),\n  site_id = as.numeric(mite_long_pa$site_id),\n  Nspp = max(mite_long_pa$group_id),\n  spp_id = mite_long_pa$group_id\n),parallel_chains = 2, refresh = 0, chains = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 2 parallel chains...\n\nChain 2 finished in 5.7 seconds.\nChain 1 finished in 6.9 seconds.\n\nBoth chains finished successfully.\nMean chain execution time: 6.3 seconds.\nTotal execution time: 7.0 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidybayes::get_variables(bernoulli_mite_spp)\n```\n:::\n\n\nThis model can produce a probability that any species occurs in any plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_occ_prob_logit <- bernoulli_mite_spp |> \n  tidybayes::gather_rvars(prob_occurence[spp_id, site_id])\n\n## transform into probabilities\nmite_occ_prob <- mite_occ_prob_logit |> \n  mutate(prob = posterior::rfun(plogis)(.value))\n\nmite_occ_prob |> \n  mutate(med_prob = median(prob),\n         spp_id  = forcats::fct_reorder(as.factor(spp_id), med_prob),\n         site_id = forcats::fct_reorder(as.factor(site_id), med_prob)) |> \n  ggplot(aes(x = spp_id, y = site_id, fill = med_prob)) + \n  geom_tile()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n### Exercises:\n\n1. How could you assess this model fit to data? What kind of figure would be most interesting?\n1. The probability of a species occurring across all sites is given by `b_avg + b_spp`. How does that compare to the fraction of sites at which any species was observed?\n1. The expected species richness of each site is given by `b_avg + b_site`. How does that compare to the observed species richness?\n\n\n\n## Poisson random intercepts: Mite abundance\n\n**How does mite abundance vary among sites?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_data_long |> \n  mutate(site_id = forcats::fct_reorder(site_id, abd)) |> \n  ggplot(aes(y = site_id, x = abd)) +\n  geom_point() + \n  coord_cartesian(xlim = c(0,100)) + \n  stat_summary(fun = median, col = \"red\", geom = \"point\")\n```\n\n::: {.cell-output-display}\n![Abundance of each species at every site in the mite dataset. Points are species abundances, grouped on the row for that site.](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-tip}\n### write the model in the same notation as the original\n\nLet's model the counts of species abundances, using a random effect for each site. Write the model that corresponds to this!\n\n:::\n\n\n### Trying it with a Normal distribution:\n\nIt's actually possible to run the previous model on this one.\nlet's set up the data and try:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_numbers <- with(mite_data_long,\n     setNames(seq_along(unique(spp)), unique(spp)))\n\nmite_data_groupID <- mutate(mite_data_long,\n                            group_id = species_numbers[spp])\n\nmite_list <- with(mite_data_groupID,\n                  list(\n                    N = length(abd),\n                    y = abd,\n                    Ngroup = dplyr::n_distinct(spp),\n                    group_id = group_id\n                  ))\n\nnormal_samples <- hierarchical_groups$sample(data = mite_list, refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpWhWKuf/model-473001618f1b5.stan', line 15, column 2 to column 33)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpWhWKuf/model-473001618f1b5.stan', line 15, column 2 to column 33)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 2 \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpWhWKuf/model-473001618f1b5.stan', line 15, column 2 to column 33)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 1.9 seconds.\nChain 2 finished in 1.9 seconds.\nChain 3 finished in 2.1 seconds.\nChain 4 finished in 2.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 2.0 seconds.\nTotal execution time: 2.2 seconds.\n```\n:::\n:::\n\n\nThis is interesting, but it would probably be better to fit this model with something meant for counts! With this comes the need to include a log link function. Fortunately, Stan makes all this possible with just a few small changes:\n\n### Exercise: translate it into Stan\n\nModify the program `hierarchical_groups.stan` to work for poisson data. Some things to keep in mind: \n\n* `data {}` block: remember that the Poisson distribution needs integers and set up the data inputs accordinly.\n* `parameters {}` block: think about which parameters the poisson does NOT need. \n* `model {}` block: remember to remove any unneeded parameters from the likelihood (the model of the data), and their priors too.\n* replace `normal` with `poisson_log`. Note that this evaluates its argument on the log scale. That is, it works like a typical GLM done in R. We can keep priors the same as in the last model, though we may decide to change their values.\n* `generated quantities {}` block: replace `normal_rng()` with `poisson_log_rng()` -- _where necessary_ -- and delete unused parameters.\n* again, remember that the Poisson needs to be making integers. For example, replace `vector[Ngroup]` with `array[Ngroup] int `\n\n\n\n\n\n### Exercises\n\n* Try modifying the program again, this time adding a predictor: water content. What happens to `sigma_grp` in this example?\n\n\n\n## Extra stuff\n\nLet's use simulations to demonstrate that univariate normal distributions are special cases of multivariate normal distributions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmysigma <- 3\nnsamp <- 1100\n\nhist(rnorm(nsamp, 0, mysigma))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmySigma <- diag(mysigma, nrow = nsamp)\n\nmv_numbers <- MASS::mvrnorm(1, mu = rep(0, nsamp), Sigma = mySigma)\nhist(mv_numbers)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}