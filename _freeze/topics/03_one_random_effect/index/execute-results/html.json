{
  "hash": "2db780eea3ab7adffe91aa0ded9d0de9",
  "result": {
    "markdown": "---\ntitle: \"Models with one level of hierarchy\"\ndescription: |\n  Some of these things are somewhat like the others.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n:::{.callout-tip}\n## Bayesian workflow\n\n1. Visualize your data\n2. Decide on your model structure\n3. Simulate from the model to understand it\n4. Fit the model to the data\n5. Plot model predictions to evaluate the fit / draw conclusions\n:::\n\nToday's goal is to look at a couple of different model structures that we saw yesterday. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is cmdstanr version 0.7.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan path: /home/andrew/software/cmdstan\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan version: 2.34.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidybayes)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n## Gaussian random intercepts: Penguin body mass\n\n**Are populations of penguins on different islands different in their body mass?**\n\nThe Palmer penguins are found on three different islands. Let's look at the distribution of body mass of each species on each island.\n\n### Plot the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island <- penguins |> \n  select(species, island, body_mass_g) |> \n  drop_na(body_mass_g) |> \n  unite(sp_island, species, island) |> \n  ## center mass and change the units\n  mutate(mass_kg = (body_mass_g)/1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  ggplot(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gauss-inter-plot-1.png){width=672}\n:::\n:::\n\n\nAre the sample sizes equal among the species-island combinations?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_mass_island |> \n  count(sp_island) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|sp_island        |   n|\n|:----------------|---:|\n|Adelie_Biscoe    |  44|\n|Adelie_Dream     |  56|\n|Adelie_Torgersen |  51|\n|Chinstrap_Dream  |  68|\n|Gentoo_Biscoe    | 123|\n:::\n:::\n\n\n### Decide on a model structure\n\nWe'll begin by fitting a model that assumes that body size for each of these five groups is completely independent:\n\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5)\n\\end{align}\n$$\n\n### Simulate to understand this model {#sec-fixed-simulation}\n\nHere's a little trick to get group indexes (numbers) from a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_names <- unique(penguin_mass_island$sp_island)\ngroup_numbers <- seq_along(group_names)\nnames(group_numbers) <- group_names\n\ngroup_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdelie_Torgersen    Adelie_Biscoe     Adelie_Dream    Gentoo_Biscoe \n               1                2                3                4 \n Chinstrap_Dream \n               5 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_groupid <- penguin_mass_island |> \n  mutate(group_id = group_numbers[sp_island])\n\npenguin_groupid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 342 × 4\n   sp_island        body_mass_g mass_kg group_id\n   <chr>                  <int>   <dbl>    <int>\n 1 Adelie_Torgersen        3750    3.75        1\n 2 Adelie_Torgersen        3800    3.8         1\n 3 Adelie_Torgersen        3250    3.25        1\n 4 Adelie_Torgersen        3450    3.45        1\n 5 Adelie_Torgersen        3650    3.65        1\n 6 Adelie_Torgersen        3625    3.62        1\n 7 Adelie_Torgersen        4675    4.68        1\n 8 Adelie_Torgersen        3475    3.48        1\n 9 Adelie_Torgersen        4250    4.25        1\n10 Adelie_Torgersen        3300    3.3         1\n# ℹ 332 more rows\n```\n:::\n:::\n\n\nAs you can see, we're set up now with the names and the indexes we need. \n\nNow we can simulate data and plot it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nngroup <- length(group_numbers)\noverall_mean <- rnorm(1, mean = 5, sd = 2)\ngroup_diffs <- rnorm(n = ngroup, mean = 0, sd = 1)\nsigma_obs <- rexp(1, .5)\n\npenguin_pred_obs <- penguin_groupid |> \n  mutate(fake_mass_avg = overall_mean + group_diffs[group_id],\n         fake_mass_obs = rnorm(length(fake_mass_avg), \n                               mean = fake_mass_avg, \n                               sd = sigma_obs))\n\npenguin_pred_obs |> \n  ggplot(aes(y = sp_island,\n             x = fake_mass_obs,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-tip}\n### EXERCISE\nRun the above code a few times! if you want, try different prior values.\n:::\n\n### Write it in Stan\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/fixed_groups.stan\")\n\nfixed_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma);\n  b_group ~ std_normal();\n  b_avg ~ normal(5, 2);\n  sigma ~ exponential(.5);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma);\n  }\n}\n```\n:::\n:::\n\n\n### Fit the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_group_list <- with(penguin_groupid, \n         list(\n           N = length(mass_kg),\n           y = mass_kg,\n           Ngroup = max(group_id),\n           group_id = group_id\n         ))\n\nfixed_groups_samples <- fixed_groups$sample(\n  data = peng_group_list,\n  refresh = 0,\n  parallel_chains = 4\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpH4tcI4/model-4700c1ddd09d5.stan', line 13, column 2 to column 47)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 3 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 0.4 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 0.4 seconds.\n```\n:::\n:::\n\n\n### Plot predictions to evaluate results\n\n\nLet's begin by plotting the averages for each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups_samples |> \n  gather_rvars(group_averages[group_id]) |> \n  mutate(sp_island = names(group_numbers)[group_id]) |> \n  ggplot(aes(y = sp_island, dist = .value)) + \n  stat_pointinterval() + \n  geom_jitter(data = penguin_mass_island,\n              aes(y = sp_island,\n                  x = mass_kg,\n                  colour = sp_island), \n              pch = 21, inherit.aes = FALSE,\n              alpha = 0.8, height = 0.1, width = 0) + \n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nSome things to notice about the code above: \n\n* I'm using my named vector `group_numbers` to re-create the column `sp_island`. This is my technique for making sure I always use the correct label, but you can do this any way you want.\n* We use `tidybayes::stat_pointinterval()` to summarize the posterior distribution.\n* we're adding points from the original data (`penguin_mass_island`) with `geom_jitter()`. We're adding noise vertically to make the visualization better, but not adding any horizontal noise.\n\n:::{.callout-tip}\n### EXERCISE: plot posterior predictions of _observations_\n\nRepeat the exercise above using the value of `one_obs_per_group`. \nWhy are the results different? What additional error is included in these predictions?\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id]) |> \n  mutate(sp_island = group_names[group_id]) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval(colour = \"black\") + \n  geom_jitter(\n    aes(y = sp_island,\n        x = mass_kg,\n        colour = sp_island), \n    inherit.aes = FALSE,\n    alpha = .2, data = penguin_groupid, height = .2, width = 0) + \n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n:::\n\n### Make it hierarchical\n\n#### Math\n\n\n:::{.column-screen}\n\n::::{.columns}\n\n::: {.column width=\"2.5%\"}\n:::\n\n::: {.column width=\"45%\"}\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, 1) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5)\n\\end{align}\n$$\n:::\n\n::: {.column width=\"5%\"}\n\n:::\n\n::: {.column width=\"45%\"}\n$$\n\\begin{align}\n\\text{Body mass}_i &\\sim \\text{Normal}(\\mu_i, \\sigma_{\\text{obs}}) \\\\\n\\mu_i &= \\bar\\beta + \\beta_{\\text{group}[i]} \\\\\n\\bar\\beta &\\sim \\text{Normal}(5, 2) \\\\\n\\beta_{\\text{group}} &\\sim \\text{Normal}(0, \\sigma_{\\text{sp}}) \\\\\n\\sigma_{\\text{obs}} &\\sim \\text{Exponential}(.5) \\\\\n\\sigma_{\\text{sp}} &\\sim \\text{Exponential}(1)\n\\end{align}\n$$\n\n:::\n\n::: {.column width=\"2.5%\"}\n\n:::\n\n::::\n\n:::\n\n#### Simulation of a hierarchical model\n\n:::{.callout-tip}\n### EXERCISE \nSimulate from the model above. Base your approach on the [code for simulation the non-hierarchical version](#sec-fixed-simulation). \nRemember to simulate one additional number: the standard deviation of group differences\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n::: {.cell}\n\n```{.r .cell-code}\nngroup <- length(group_numbers)\noverall_mean <- rnorm(1, mean = 5, sd = 2)\nsigma_group <- rexp(1, .1)\ngroup_diffs <- rnorm(n = ngroup, mean = 0, sd = sigma_group)\nsigma_obs <- rexp(1, .5)\n\npenguin_pred_obs <- penguin_groupid |> \n  mutate(fake_mass_avg = overall_mean + group_diffs[group_id],\n         fake_mass_obs = rnorm(length(fake_mass_avg), \n                               mean = fake_mass_avg, \n                               sd = sigma_obs))\n\npenguin_pred_obs |> \n  ggplot(aes(y = sp_island,\n             x = fake_mass_obs,\n             colour = sp_island)) + \n  geom_jitter(alpha = 0.8, height = 0.1, width = 0) + \n  scale_color_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n:::\n\n#### Stan\n\n\nBelow I'm comparing the two Stan programs side-by-side. Compare them to the models above! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups <- cmdstan_model(stan_file = \"topics/03_one_random_effect/hierarchical_groups.stan\")\n```\n:::\n\n\n:::{.column-screen}\n\n::::{.columns}\n\n::: {.column width=\"2.5%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma);\n  b_group ~ std_normal();\n  b_avg ~ normal(5, 2);\n  sigma ~ exponential(.5);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma);\n  }\n}\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"5%\"}\n\n:::\n\n::: {.column width=\"45%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\ndata {\n  int<lower=0> N;\n  vector[N] y;\n  int<lower=0> Ngroup;\n  array[N] int<lower=0, upper=Ngroup> group_id;\n}\nparameters {\n  real b_avg;\n  vector[Ngroup] b_group;\n  real<lower=0> sigma_obs;\n  real<lower=0> sigma_grp;\n}\nmodel {\n  y ~ normal(b_avg + b_group[group_id], sigma_obs);\n  b_group ~ normal(0, sigma_grp);\n  b_avg ~ normal(5, 2);\n  sigma_obs ~ exponential(.5);\n  sigma_grp ~ exponential(1);\n}\ngenerated quantities {\n  \n  vector[Ngroup] group_averages;\n  \n  for (k in 1:Ngroup){\n    group_averages[k] = b_avg + b_group[k];\n  }\n  \n  // predict making one new observation per group\n  vector[Ngroup] one_obs_per_group;\n  \n  for (k in 1:Ngroup) {\n    one_obs_per_group[k] = normal_rng(group_averages[k], sigma_obs);\n  }\n  \n  // difference for a new group\n  real new_b_group = normal_rng(0, sigma_grp);\n  \n  // observations from that new group\n  real one_obs_new_group = normal_rng(b_avg + new_b_group, sigma_obs);\n  \n}\n```\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"2.5%\"}\n\n:::\n\n::::\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples <- hierarchical_groups$sample(\n  data = peng_group_list, refresh = 0, parallel_chains = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 parallel chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpWhWKuf/model-473001618f1b5.stan', line 15, column 2 to column 33)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 0.4 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\nChain 4 finished in 0.4 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.4 seconds.\nTotal execution time: 0.4 seconds.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n lp__              88.39  88.71 2.14 1.99 84.52 91.22 1.00      950     1692\n b_avg              4.02   4.01 0.37 0.32  3.45  4.65 1.01      519      643\n b_group[1]        -0.31  -0.29 0.38 0.33 -0.95  0.27 1.01      539      642\n b_group[2]        -0.31  -0.29 0.38 0.32 -0.96  0.28 1.01      535      632\n b_group[3]        -0.33  -0.32 0.38 0.33 -0.97  0.24 1.01      523      652\n b_group[4]         1.05   1.06 0.37 0.32  0.43  1.62 1.01      530      638\n b_group[5]        -0.29  -0.28 0.38 0.32 -0.92  0.29 1.01      529      660\n sigma_obs          0.47   0.46 0.02 0.02  0.44  0.50 1.00     1808     1534\n sigma_grp          0.79   0.69 0.37 0.25  0.41  1.43 1.00     1167      977\n group_averages[1]  3.71   3.71 0.07 0.07  3.60  3.81 1.00     4589     2590\n\n # showing 10 of 21 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(b_group[group_id],\n                          new_b_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhierarchical_groups_samples |> \n  tidybayes::gather_rvars(one_obs_per_group[group_id],\n                          one_obs_new_group) |> \n  mutate(sp_island = group_names[group_id],\n         sp_island = if_else(is.na(sp_island),\n                             true = \"New Group\",\n                             false = sp_island)) |> \n  ggplot(aes(y = sp_island,\n             dist = .value,\n             colour = sp_island)) + \n  stat_pointinterval() + \n  geom_point(aes(y = sp_island,\n             x = mass_kg,\n             colour = sp_island), \n             inherit.aes = FALSE,\n             alpha = .2, data = penguin_groupid)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n### Exercises\n\n1. Try leaving out a group and refitting the hierarchical model. Are the predictions for the missing group accurate?\n1. There are other categorical predictors in the dataset. Try including `year` as a part of the group-creating factor (i.e. in the call to `unite()` above). What changes?\n1. Modify the `generated quantities` block to simulate a fake observation for EVERY row of the dataset. This opens the possibility of using `bayesplot` to make predictions. Look back at the code from Day 1 and create a posterior predictive check for both models. (e.g. using `ppc_dens_overlay`)\n1. We could perhaps have used `sex` as a grouping factor, but `sex` has missing values in it! Why is this a problem for this kind of model? What would it take to address that? (Discussion only; missing values are unfortunately outside the scope of the class!)\n\n## Observation-level random effects: Mite abundance\n\n### What is the question? \n\nLet's write a model to answer the question:  \n\n**How does the total abundance of the mite community change as water content increases?**  \n\n### Express this in Math\n\nHere's a partially complete model for species richness over time\n\n$$\n\\begin{align}\n\\text{S}_i &\\sim \\text{Poisson}(e^a) \\\\\na &= \\bar\\beta + \\beta_{\\text{water}} \\cdot \\text{water}_i \\\\\n\\bar\\beta &\\sim \\text{Normal}(?, ?) \\\\\n\\beta_{\\text{water}} &\\sim \\text{Normal}(?, ?) \\\\\n\\end{align}\n$$\n\n:::{.callout-tip}\n### EXERCISE \nSimulate from this model, and look at your simulations to decide on a reasonable prior for the data.\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 30\nwater <- seq(from = -5, to = 5, length.out = n)\n\nb0 <- rnorm(1, mean = log(17), sd = .3)\nb1 <- rnorm(1, mean = 0, sd = .2)\n\nS <- rpois(n, lambda = exp(b0 + b1*water))\nplot(water, S)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n:::\n\n### Data preparation & visualization\n\nFirst we need to load and prepare the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\n\n# combine data and environment\n\nmite_data_long <- mite |> \n  tibble::rownames_to_column(var = \"site_id\") |> \n  bind_cols(mite.env) |> \n  pivot_longer(Brachy:Trimalc2,\n               names_to = \"spp\", values_to = \"abd\")\n```\n:::\n\n\n\nFirst let's transform the mite dataset into a dataframe of total community abundance (N) per site. \nWe'll also standardize the water content while we're at it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmite_community_abd <- mite_data_long |> \n  group_by(site_id, WatrCont) |> \n  summarize(N = sum(abd)) |>\n  ungroup() |> \n  mutate(water_c = (WatrCont - mean(WatrCont))/100)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'site_id'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nknitr::kable(head(mite_community_abd))\n```\n\n::: {.cell-output-display}\n|site_id | WatrCont|   N|    water_c|\n|:-------|--------:|---:|----------:|\n|1       |   350.15| 140| -0.6048571|\n|10      |   220.73| 166| -1.8990571|\n|11      |   134.13| 216| -2.7650571|\n|12      |   405.91| 213| -0.0472571|\n|13      |   243.70| 177| -1.6693571|\n|14      |   239.51| 269| -1.7112571|\n:::\n:::\n\n\nWe get a nice histogram of community abundance, and a clear negative relationship with water volume:\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nmite_community_abd |> \n  ggplot(aes(x = N)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmite_community_abd |> \n  ggplot(aes(x = water_c, y = N)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n:::\n\n\n### Write the model in Stan and estimate it\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_regression <- cmdstan_model(stan_file = \"topics/03_one_random_effect/poisson_regression.stan\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwater_for_pred <- seq(from = -3, to = 4.5, length.out = 15)\n\nabd_data_list <- list(N = length(mite_community_abd$N),\n              water = mite_community_abd$water_c,\n              y = mite_community_abd$N,\n              Npred = 15,\n              water_pred = water_for_pred)\n\npoisson_regression_sample <- poisson_regression$sample(\n  data = abd_data_list,\n  refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.5 seconds.\n```\n:::\n:::\n\n\n### Plot the model to see if it fits well\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\npoisson_regression_sample |> \n  tidybayes::gather_rvars(line_obs[i]) |> \n  mutate(water = water_for_pred) |> \n  ggplot(aes(x = water, dist = .value)) + \n  stat_lineribbon() + \n  geom_point(aes(x = water_c, y = N), \n             data = mite_community_abd, \n             inherit.aes = FALSE) + \n  scale_fill_brewer(palette = \"Greens\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\nfake_obs_S <- poisson_regression_sample$draws(variables = \"fake_obs\")\nfake_obs_S_matrix <- posterior::as_draws_matrix(fake_obs_S)\n\nbayesplot::ppc_dens_overlay(y = mite_community_abd$N,\n                            yrep = head(fake_obs_S_matrix, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-2.png){width=672}\n:::\n:::\n\n\nRemember, on the left we are plotting the _*Prediction interval*_ here: it's showing the distribution of probable observations according to the model. Notice that the the model predicts much narrower variation than we really find!   \n\nOn the right hand side we have the posterior predictive check, which once again shows that the model is overconfident and predicts a range of observations that are far too narrow.  \n\n\n\n:::{.callout-tip\n### EXERCISE\n\n1) Discuss with your neighbours: would you trust this model? Would you publish it? The technical name for this phenomenon is \"overdisperson\". Have you checked for this in previous count models you've done?\n\n2) Add a random effect for _every individual observation_ in the model. Begin by writing the mathematical notation for this new model! \n\n3) fit the model and re-create the two figures above. What do you notice? \n\n* Which model is more trustworthy?\n* look at the slope in the new model. Is it different?\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n#### Mathematical notation\n\n$$\n\\begin{align}\n\\text{S}_i &\\sim \\text{Poisson}(e^a) \\\\\na &= \\bar\\beta + \\beta_{\\text{water}} \\cdot \\text{water}_i + \\text{site}_i\\\\\n\\bar\\beta &\\sim \\text{Normal}(?, ?) \\\\\n\\beta_{\\text{water}} &\\sim \\text{Normal}(?, ?) \\\\\n\\text{site} &\\sim \\text{Normal}(?, \\sigma) \\\\\n\\sigma &\\sim \\text{Exponential}(?)\n\\end{align}\n$$\n\n#### Stan code \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_regression_overdisp <- cmdstan_model(stan_file = \"topics/03_one_random_effect/poisson_regression_overdisp.stan\")\n\npoisson_regression_overdisp_sample <- poisson_regression_overdisp$sample(\n  data = abd_data_list, refresh = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning MCMC with 4 sequential chains...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpIhvutV/model-471231bcd7800.stan', line 18, column 2 to column 42)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 1 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1 finished in 0.3 seconds.\nChain 2 finished in 0.3 seconds.\nChain 3 finished in 0.3 seconds.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Informational Message: The current Metropolis proposal is about to be rejected because of the following issue:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 Exception: normal_lpdf: Scale parameter is 0, but must be positive! (in '/tmp/RtmpIhvutV/model-471231bcd7800.stan', line 18, column 2 to column 42)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 If this warning occurs sporadically, such as for highly constrained variable types like covariance matrices, then the sampler is fine,\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 but if this warning occurs often then your model may be either severely ill-conditioned or misspecified.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nChain 4 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 4 finished in 0.3 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.3 seconds.\nTotal execution time: 1.3 seconds.\n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nfake_obs_S <- poisson_regression_overdisp_sample$draws(variables = \"fake_obs\")\nfake_obs_S_matrix <- posterior::as_draws_matrix(fake_obs_S)\n\nbayesplot::ppc_dens_overlay(y = mite_community_abd$N,\n                            yrep = head(fake_obs_S_matrix, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\npoisson_regression_overdisp_sample |> \n  tidybayes::gather_rvars(line_obs[i]) |> \n  mutate(water = water_for_pred) |> \n  ggplot(aes(x = water, dist = .value)) + \n  stat_lineribbon() + \n  geom_point(aes(x = water_c, y = N), \n             data = mite_community_abd, \n             inherit.aes = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n:::\n\n\n:::\n\n\n\n:::{.callout-note}\nAnother great way to model overdispersion is via the [Negative Binomial](https://en.wikipedia.org/wiki/Negative_binomial_distribution) distribution. Look at the Stan documentation for [neg_binomial_2_log](https://mc-stan.org/docs/functions-reference/neg-binom-2-log.html) and adapt your model to use it (don't forget to drop the random effect when you do!).\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}