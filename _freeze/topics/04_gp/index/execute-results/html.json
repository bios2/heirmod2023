{
  "hash": "d3e13d3b1306709b1dfdf32a57daa78a",
  "result": {
    "markdown": "---\ntitle: \"Gaussian Processes in Stan\"\ndescription: |\n  Smooth lines in fancy colours.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\n---\n\n\n\n:::{.callout-tip}\n## Goals of this lesson\n1. Let's appreciate together the power of online community resources\n1. Gaussian Processes are families of smooth functions we learn from data\n1. When used for prediction, a GP is both a \"prior\" and a \"likelihood\"\n:::\n\n## Background reading\n\nGaussian processes are very common, and there are lots of resources on the topic:\n\n1. The Stan manual [has a chapter on it](https://mc-stan.org/docs/stan-users-guide/gaussian-processes.html)\n1. The Stan team gives lots of [example models on Github](https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan) which I adapted for this example.\n1. Michael Betancourt has an extremely detailed, very rigous [tutorial on GPs](https://betanalpha.github.io/assets/case_studies/gaussian_processes.html#3_Inferring_A_Gaussian_Process)\n1. Here's a complete, worked [analysis of human birthdays](https://avehtari.github.io/casestudies/Birthdays/birthdays.html#Model_4:_long_term_smooth_+_seasonal_+_weekday_with_increasing_magnitude) by world-class statisticians (Gelman, Vehtari, Simpson, et al)\n1. GPs are related to GAMs and can be represented by a collection of basis functions. This is approximate but much much faster. See this [excellent tutorial](https://avehtari.github.io/casestudies/Motorcycle/motorcycle_gpcourse.html#45_GP_with_basis_functions_for_f_and_g) by Aki Vehtari, and the corresponding paper (citation in the blog post).\n1. this [blog](https://rpubs.com/NickClark47/stan_geostatistical) applies GPs to spatial count data\n1. Here is a very long and wonderfully detailed post describing a GP approach to [occupany modelling](https://peter-stewart.github.io/blog/gaussian-process-occupancy-tutorial/)\n1. Another [blog on Gaussian Processes](https://brendanhasz.github.io/2018/10/10/hmm-vs-gp.html#generating-data-from-a-gaussian-process), Hidden Markov Models and more, very clear explanation.\n\n<!-- add equation -->\n\n<!-- add simulation -->\n\n### Reorganizing the mite data\n\nLet's begin by (once again!) loading and reorganizing the mite data. This time we'll also use `mite.xy`, which gives the coordinates of each one of the 70 samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# today we need to do the \ndata(mite, package = \"vegan\")\ndata(\"mite.env\", package = \"vegan\")\ndata(\"mite.xy\", package = \"vegan\")\nlibrary(tidyverse)\nlibrary(cmdstanr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is cmdstanr version 0.5.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan path: /Users/amacdonald/.cmdstan/cmdstan-2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- CmdStan version: 2.31.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable CMDSTANR_NO_VER_CHECK=TRUE.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# combine data and environment\nmite_data_long <- bind_cols(mite.env, mite) |> \n  mutate(plot_id = 1:length(WatrCont)) |> \n  pivot_longer(Brachy:Trimalc2, names_to = \"spp\", values_to = \"abd\")\n\n\nmite_data_long_transformed <- mite_data_long |> \n  mutate(presabs = as.numeric(abd>0),\n         # center predictors\n         water = (WatrCont - mean(WatrCont)) / 100\n         )\n\n# pick a species that has about 50/50 chance \n\nmite_data_long_transformed |>\n  group_by(spp) |>\n  summarize(freq = mean(presabs)) |>\n  filter(freq > .4 & freq < .6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   spp       freq\n   <chr>    <dbl>\n 1 Ceratoz3 0.443\n 2 FSET     0.429\n 3 HMIN     0.486\n 4 MEGR     0.543\n 5 NCOR     0.5  \n 6 Oppiminu 0.429\n 7 Oribatl1 0.429\n 8 PWIL     0.486\n 9 TVEL     0.557\n10 Trhypch1 0.457\n```\n:::\n\n```{.r .cell-code}\n## how about: PWIL \n```\n:::\n\n\nLet's choose just one species as an example. \nI've chosen one where the relationship with water is rather strong, and for which presence and absence are roughly balanced. \nThis is just to make the example clear.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npwil_data <- mite_data_long_transformed |> \n  filter(spp == \"PWIL\")\n\npwil_data |> \n  ggplot(aes(x = water, y = presabs)) + geom_point() + \n  stat_smooth(method = glm, method.args = list(family = \"binomial\")) + \n  theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![Probability of occurrance of one mite species, as a fuction of water content of the soil](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# add the spatial coordinates:\n\npwil_spatial <- bind_cols(pwil_data, mite.xy)\n\npwil_spatial |> \n  ggplot(aes(x = x, y = y, fill = as.factor(presabs))) + \n  geom_point(size = 3, pch = 21, stroke = 1) + \n  scale_fill_brewer(type = \"qual\", palette = \"Dark2\") + \n  theme_minimal() + \n  coord_fixed() + \n  labs(fill = \"Pres/Abs\")\n```\n\n::: {.cell-output-display}\n![Presence-absence data for mite species \"PWIL\", at the spatial location of each point.](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nWe'll look at two possibilities in turn:  \n\n1. A nonlinear function of one variable\n1. A smooth function of distance\n\n# Smooth function of one variable\n\n## Write the model\n\n## Simulate to understand it\n\n## Express that model in code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_pred <- cmdstan_model(\n  stan_file = \"topics/04_gp/gp_example_pred.stan\")\n\ngp_example_pred\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  int<lower=1> Nobs;\n  int<lower=1> N;\n  array[N] real x;\n  array[Nobs] int<lower=0, upper=1> z;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n    \n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n    \n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(5, 14);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n  \n  z ~ bernoulli_logit(a + f[1:Nobs]);\n}\n```\n:::\n:::\n\n\nWe need to generate data for making predictions! I'll create a new vector of observations called `new_x` that cover the range of the `water` variable in our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample N values on the range of x\nnew_x <- seq(from = -3, to = 5, length.out = 15)\n\n# put them on the dataframe\ngp_example_samp <- gp_example_pred$sample(\n  data = list(N = length(pwil_spatial$presabs) + length(new_x),\n              Nobs = length(pwil_spatial$presabs),\n              x = c(pwil_spatial$water, new_x),\n              z = pwil_spatial$presabs),\n  chains = 2, parallel_chains = 2, refresh = 1000)\n\ngp_example_samp$save_object(\"topics/04_gp/gp_example_samp_pwil.rds\")\n```\n:::\n\n\n:::{.callout-tip}\nNote that `cmdstanr` models have a method called `$save_object()`, which lets you save the model outputs into an `.rds` object.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample N values on the range of x\nnew_x <- seq(from = -3, to = 5, length.out = 15)\n\ngp_example_samp_pwil <- read_rds(\n  \"topics/04_gp/gp_example_samp_pwil.rds\")\n\nwater_prediction_points <- gp_example_samp_pwil |> \n  tidybayes::gather_rvars(f[rownum]) |> \n  slice(-(1:length(pwil_spatial$presabs)))\n\nwater_prediction_points |> \n  mutate(water = new_x,\n         presabs = posterior::rfun(plogis)(.value)) |> \n  ggplot(aes(x = water, dist = presabs)) + \n  tidybayes::stat_lineribbon() + \n  # scale_fill_viridis_d(option = \"rocket\") + \n  scale_fill_brewer(palette = \"Reds\", direction  = -1) + \n  geom_jitter(aes(x = water, y = presabs), \n              inherit.aes = FALSE, \n              height = .01, width = 0,\n              data = pwil_spatial)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using the `size` aesthetic with geom_ribbon was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `linewidth`.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using the `size` aesthetic with geom_line was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `linewidth`.\nUnknown or uninitialised column: `linewidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"topics/04_gp/pwil_water.png\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSaving 7 x 5 in image\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `linewidth`.\nUnknown or uninitialised column: `linewidth`.\nUnknown or uninitialised column: `linewidth`.\n```\n:::\n:::\n\n\n<!-- ![](topics/04_gp/pwil_water.png) -->\n\nWe can also pull out some specific functions. What I want you to see here is that there are MANY curvy lines that are consistent with this model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_predicted_lines <-  gp_example_samp_pwil |> \n  # take just some draws\n  tidybayes::spread_draws(a, f[rownum], ndraws = 63) |> \n  # remove the rows that match observed data,\n  # and look only at the points for predictions.\n  filter(rownum > length(pwil_spatial$presabs)) |> \n  # convert to probability\n  mutate(prob = plogis(f + a),\n         rownum = rownum - 70) |> \n  ## need a dataframe that says which \"rownum\" from \n  ## above goes with which value of water from the\n  ## new_x vector I made:\n  left_join(tibble::enframe(new_x,\n                            name = \"rownum\", \n                            value = \"water\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(rownum)`\n```\n:::\n\n```{.r .cell-code}\nsome_predicted_lines |> \n  ggplot(aes(x = water, y = prob, group = .draw)) + \n  geom_line(alpha = 0.7) + \n  theme_minimal() + \n  coord_cartesian(ylim = c(0, 1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n# Spatial predictions\n\nTo make a prediction of a function on one X variable, we needed a sequence of points to predict along. \n\nTo make spatial predictions, we need a _grid_ of points to predict along.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_points <- modelr::data_grid(mite.xy, \n                                 x = modelr::seq_range(x, by = .5),\n                                 y = modelr::seq_range(y, by = .5)) \n\ngrid_points |> \n  ggplot(aes(x = x, y = y)) + \n  geom_point() + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nOther than a change in the `data {}` block, the Stan code is unchanged! \n\n:::{.callout-warning}\n## CAUTION: Slow\nThe model below, over 70 points, is the slowest model we've seen so far and takes about 7 minutes on my (Andrew's) laptop.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_pred_2D <- cmdstan_model(\n  stan_file = \"topics/04_gp/gp_example_pred_2D.stan\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in readLines(stan_file): incomplete final line found on\n'topics/04_gp/gp_example_pred_2D.stan'\n```\n:::\n\n```{.r .cell-code}\ngp_example_pred_2D\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.stan}\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  int<lower=1> Nobs;\n  int<lower=1> N;\n  array[N] vector[2] x;\n  array[Nobs] int<lower=0, upper=1> z;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n    \n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n    \n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(5, 14);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n  \n  z ~ bernoulli_logit(a + f[1:Nobs]);\n}\n```\n:::\n:::\n\n\nplot the effect in space:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## sample the model\ngp_example_2D_samp <- gp_example_pred_2D$sample(\n  data = list(N = length(pwil_spatial$presabs) + nrow(grid_points),\n              Nobs = length(pwil_spatial$presabs),\n              x = bind_rows(pwil_spatial[c(\"x\", \"y\")], grid_points),\n              z = pwil_spatial$presabs),\n  chains = 2, parallel_chains = 2, refresh = 1000)\n\n\ngp_example_2D_samp$save_object(\"topics/04_gp/gp_example_2D_samp_pwil.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_2D_samp_pwil <- read_rds(\"topics/04_gp/gp_example_2D_samp_pwil.rds\")\n\n## extract the predictors\ngp_example_2D_samp_pwil |> \n  tidybayes::spread_rvars(f[rownum], a) |> \n  slice(-(1:length(pwil_spatial$presabs))) |> \n  bind_cols(grid_points) |> \n  mutate(presabs = posterior::rfun(plogis)(f + a),\n         pa_median = median(presabs)) |> \n  ggplot(aes(x = x, y = y, fill = pa_median)) + \n  geom_tile()+\n  geom_point(aes(x = x,\n                 y = y,\n                 fill = presabs),\n             inherit.aes = FALSE,\n             data = pwil_spatial,\n             pch = 21 ,\n             size = 2.5,\n             stroke = .3,\n             colour = \"lightblue\"\n             ) + \n  scale_fill_viridis_c(option = \"rocket\") + \n  coord_fixed()+\n  theme_minimal() + \n  labs(fill = \"Pr(y=1)\") + \n  NULL \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"topics/04_gp/pwil_spatial.png\")\n```\n:::\n\n\n<!-- ![](topics/04_gp/pwil_spatial.png) -->\n\n## Extensions:\n\nAdd water to the model. Does the spatial effect disappear, increase, or stay kind of the same?\n\nNext step: try to model water curve for more than one species. Would it be possible to make the species rho parameters hierarchical?\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}